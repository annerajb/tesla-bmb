; dasm notes working copy for kenny
; feb - march 4, 2017 10:45

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

; Collin Kidder's 8051 Disassembler for SiLabs C8051F530 processors.
; Key to reading the assembly:
; Literal values are preceded by #0x
; FLASH locations are preceded by 0x (no #)
; RAM locations are preceded by X
; SFRs are shown as their name.
; Only code that has a valid execution path is decoded.
; Everything else presumed to be data.
; Data returned in hexadecimal and as a character if printable

;Some relevant places where significant things happen:
;SBUF reading (Getting a byte from UART): 
;   0x070A - Write to RAM location 0x66
;   0x0AC7 - Write to RAM location 0x66 - Called from 0x0903 only
;   0x0DE1 - Write to RAM location 0x2A - Within UART interrupt handler code
;SBUF writing (Sending byte out UART, goes to daisy chain/BMS master):
;   0x0AE9 - Sends byte stored in R7: #01, #06, #1F, #79
;   0x0AF8 - Part of same routine as 0xAC7 above, forwards bytes
;   0x0E04 - Part of UART interrupt handler code
;   0x1271 - Send byte stored in R7, called from 0x0EC5
;SPIDAT reading (Get byte from SPI):
;   0x11B2 - The only place SPI is ever read from. Store to R7 (gets passed thru to UART?)
;SPIDAT writing (send a byte out SPI):
;   0x0FE0 - Write from accum
;   0x11A5 - Write from accum
;Flash Write and Erase:
;	0x097E - Routine to write data to Flash Memory
;		0x084D - sub to check the key and set W/E enable control
;		0x0BDE - sub to turn off controls and disable W/E
;MOVC calls using DPTR (read data bytes from FLASH):
;   0x00A5, 0x00D2, 0x010A, 0x010F, 0x039C, 0x042C, 0x0430, 0x043E, 0x0469, 0x0477, 0x0486, 0x048A
;   0x0561, 0x057A, 0x0891, 0x0A50, 0x0A54, 0x0B81, 0x0D3D, 0x0D41, 0x0D4F, 0x0D7A, 0x0D88, 0x0D97
;   0x0D9B, 0x0D9F, 0x0E57, 0x101D, 0x10FF, 0x1103 (Yes, really that many places...)
;MOVC Calls using PC (Read bytes from flash relative to current instruction)
    ;0x044E, 0x0D5F
;MOVX Reads (Get bytes from XRAM via DPTR):
;   0x0095, 0x009E, 0x00B4, 0x00C5, 0x00ED, 0x00F1, 0x00FE, 0x0102, 0x0E39, 0x0EA4
;MOVX Writes (Write a byte into RAM via DPTR):
;   0x00DB, 0x00E4, 0x0118, 0x011C, 0x0129, 0x012D, 0x01A0, 0x01A3, 0x01A6, 0x01A9, 0x01AC, 0x01AF
;   0x0437, 0x0498, 0x09A0, 0x0D48, 0x0DA9, 0x0E60, 0x0E69;
;
;There are jump tables in Flash:
;
;  [MAIN] main loop jump table: [6 jump addresses at 0AD7] Reached via system start up. 
;    0xA1A, 0xA5B, 0x80A, 0x9A7, 0xB38, 0xBCE
;
;  [SEC] secondary loop jump table: [8 jump addresses at 0D15] Reached via [????]
;    0xF27, 0x10A2, 0x1154, 0x10B8, 0x1175, 0x11EB, 0x1279, 0x105E
;
; 8 Branch jumps/actions based upon value in register 09, at 0774 subroutine
;	Sends response and pointer addresses back to Master over UART
;
;
;
;Known uses for RAM locations:
;
; 0x1D - Used as selector for secondary loop jump table. Value 0 - 7 selects what this secondary loop will do each time.

; 0x23 - 0x26 - A 32 bit counter incremented by the timer 2 interrupt. [dptr 1245 initmem]
; 0x27 - Used in timer 2 interrupt. If it isn't zero then PCACPH2 is set to 0xFF (doing that resets watchdog timer)
; X28
; X29 -  working register to temp hold Flash Write/Erase, R1,  
; 0x2A - Byte received from UART within interrupt handler
; 0x2B - Transmitting flag used in UART interrupt handler (0 = Not transmitting, 1 = Transmitting a byte)
; 0x2C - If nonzero cause UART to forward bytes from RX to TX
; 0x2D - If nonzero maybe modify received byte before forwarding, otherwise send as-is
; X30 -  Holds Flash W/E flag
; 0x5D - 0x60 - Seems to be a 32 bit value of some sort used in timer handler [dptr 0B5F initmem]
; X61
; X64-65 Used to hold R6:R7  Flash DPTR hilo read address
; 0x66 - Used like 2A but not within interrupt handler
; 0x67 - Used like 2B but not within interrupt handler
; 0x69 - Used as selector for main loop's jump table. Value 0 - 5 selects what main loop will do each time.
;
; DPTR data tables:
;
; 0C15  - data values read during 6th jump in  secondary loop, length x100 [256 values] (101A)
; 0D15  - secondary jump table addresses [set of 8 addresses] (no separate load found, x100 above 0C15)
; 0AD7  - Main jump address table [set of 6 addresses] (indirectly loaded dph,dpl see 0A50)
; 0B5F  - InitMem data section for RAM 05 5D 00 00... (0463)
; 0B6C  - "BOOTload" bytes section (0577)
; 0B74  - 4 data bytes [81 8A 85 88] (055E)
; 0BE5  - 6 [states] data bytes 00 01 02 03 04 05 FF... (0399, 088E)
;
; 1245  - Secondary InitMem data section for RAM 06 23 00 00...  (from 0D74)
;
; Program Counter data tables:
;
; 0458  - 8 data bytes [01 02 04 08 10 20 40 80] read using the PC (used to modify values in RAM)
; 0D6C  - "  " "  " "   "
;
;
; Last line of code at 12C1

;  "Blank" Space
; 12C2 to 1CFF is blank/erased [0xFF] except for data bytes at boundary:
; 1A00 = [0x03] beginning of 14th page (072A)
; 1BFE - 1BFF = [x92 x18] last 2 bytes at end of 14th page (1p = 512 bytes, 0x200), security bytes? (from: x0726)
;
; 1D00 to 1FFF = (?written after programming using MOVX, which first erased and put) 00 everywhere except where written:
; 1D00 to 1D0D = [2 1021749-00-B]
; 1D16 to 1D2F = [0314C10000808 1009312-00-E] 
; 1D38 = tesla part number [T14C0618393]
; 1D46 to 1D4A = [90 B5 CD 84 E8] unique bytes to this bmb
;  e.g.  code2 = [86 56 C3 70 39]
;	See notes about 1DFF pointer? then maybe subtract to get back to data. 1DFF-1D4F=B9 =185.
; 
; 1E00 to 1FFF is called out as Reserved in the 8051 manual [all cleared with x00]
; so is 1DFF considered the last byte (and lock byte location) in user space?, = 0xFF
;

;Known Pin Uses:
;P1.3 - LED
;P0.0 - SPI Clock
;P0.1 - SPI MISO
;P0.2 - SPI MOSI
;P0.3 - SPI Chip Select
;P0.4 - UART Tx
;P0.5 - UART Rx

; Known Interrupt Service Routines used:
;  UART
;  Timer2
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				RESET/START ISV
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: CPU on start up - This is the Reset vector
0x0000 02 04 1C   LJMP  0x041C          ; jump to the start up routine
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Unused ISR for  INT0
;0x0003            0x02
;0x0004            0x0C
;0x0005            0x03
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Send #01 out UART
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 07AC           
0x0006 7F 01      MOV R7,  #0x01
0x0008 02 00 46   LJMP  0x0046	; routine to send R7 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Unused ISR for  Timer0
;0x000B            0x02
;0x000C            0x0C
;0x000D            0x06
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Send #06 out UART
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 07AF           
0x000E 7F 06      MOV R7,  #0x06
0x0010 02 00 46   LJMP  0x0046	; sends R7
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Unused ISR for INT1
;0x0013            0x02
;0x0014            0x0C
;0x0015            0x09
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Send #79 out UART
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 083C 077E 05D4 05ED 01D8 023A 02E1 062A 0651 
0x0016 7F 79      MOV R7,  #0x79    
0x0018 02 0A E9   LJMP  0x0AE9	; sends R7
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Unused ISR for Timer1
;0x001B            0x02
;0x001C            0x0C
;0x001D            0x0C
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Sends #1F out UART
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 07F6 0258 02EF 07BB 0675 09BF 
0x001E 7F 1F      MOV R7,  #0x1F
0x0020 02 0A E9   LJMP  0x0AE9	; sends R7
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; 				ISR for UART Interrupt
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0x0023 02 0C 0F   LJMP  0x0C0F 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Init PCA
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0B0F 
0x0026 E4         CLR A 
0x0027 F5 D9      MOV  PCAMD, A	; Keep watchdog off, system clock for PCA is Clock/12
0x0029 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;0x002A            0xFF                 ; blank filler byte
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
; 				ISR for  Timer 2 Overflow Interrupt
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0x002B 02 0C 12   LJMP  0x0C12	; 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Init Oscillator				
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0B15 
0x002E 75 B2 C7   MOV  OSCICN, #0xC7 	; set OSC ICN to 1100 0111 = Enabled in normal mode
;					; Sysclock is oscillator / 1
0x0031 22         RET 
0x0032            0xFF
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Unused ISR for SPIO Interrupt
;0x0033            0x02
;0x0034            0x0C
;0x0035            0x15
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				0B18
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; LJump Target - Callers: 0B18       	; end of first init start routine, 
0x0036 C2 AF      CLR  IE.7		; disable global interrupts
0x0038 22         RET 
0x0039            0xFF
0x003A            0xFF
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Unused ADC0 ISR
;0x003B            0x02
;0x003C            0x0C
;0x003D            0x18
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				(5C) -> R7
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0835 
0x003E AF 5C      MOV R7,  X5Ch         ; load R7 from contents of ram register 5C
0x0040 22         RET 
0x0041            0xFF
0x0042            0xFF
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;Unused ADC0 EOC ISR
;0x0043            0x02
;0x0044            0x0C
;0x0045            0x1B
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Send R7 out UART
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0008 0010 0BB7 0ABA 0AC1 066E 
0x0046 02 0A E9   LJMP  0x0AE9         ; transmits R7 out UART (to daisy chain/master)            
;0x0049            0xFF
;0x004A            0xFF
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Unused PCA ISR
0x004B            0x02
0x004C            0x0C
0x004D            0x1E
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Store R7 -> 61
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0A1C 0A38 0A5D 0A75 080C 0849 
0x004E 8F 61      MOV  X61h, R7
0x0050 22         RET 
0x0051            0xFF
0x0052            0xFF
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Unused Comp FE ISR
0x0053            0x02
0x0054            0x0C
0x0055            0x21 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Store R7 -> 68
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 053B 05A0 09F1 09E0 
0x0056 8F 68      MOV  X68h, R7
0x0058 22         RET 
0x0059            0xFF
0x005A            0xFF
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Unused Interrupt Service Routines (priority 12-18)
0x005B            0x02
0x005C            0x0C
0x005D            0x24 
0x005E            0xFF
0x005F            0xFF
0x0060            0xFF
0x0061            0xFF
0x0062            0xFF
0x0063            0x02
0x0064            0x0C
0x0065            0x27 
0x0066            0xFF
0x0067            0xFF
0x0068            0xFF
0x0069            0xFF
0x006A            0xFF
0x006B            0x02
0x006C            0x0C
0x006D            0x2A 
0x006E            0xFF
0x006F            0xFF
0x0070            0xFF
0x0071            0xFF
0x0072            0xFF
0x0073            0x02
0x0074            0x0C
0x0075            0x2D 
0x0076            0xFF
0x0077            0xFF
0x0078            0xFF
0x0079            0xFF
0x007A            0xFF
0x007B            0x02
0x007C            0x0C
0x007D            0x30 
0x007E            0xFF
0x007F            0xFF
0x0080            0xFF
0x0081            0xFF
0x0082            0xFF
0x0083            0x02
0x0084            0x0C
0x0085            0x33 
0x0086            0xFF
0x0087            0xFF
0x0088            0xFF
0x0089            0xFF
0x008A            0xFF
0x008B            0x02
0x008C            0x0C
0x008D            0x36
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;                  [Routines to read or write ACC from/to various memory types & locations]
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;					READ using R1 R2 as pointers
;                                            based upon state of R3 and Carry bit
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 05F6 06A6 0856 0861 
0x008E BB 01 06   CJNE R3,  #0x01, 0x0097   ; check state of R3 ?= 1
0x0091 89 82      MOV  DPL, R1
0x0093 8A 83      MOV  DPH, R2              ; load dptr from R1, R2
0x0095 E0         MOVX A, @DPTR             ; load Acc from dptr read of external memory
0x0096 22         RET 

; Jump Target - Callers: 008E               ; branch on R3 != +1
0x0097 50 02      JNC  0x009B
0x0099 E7         MOV  A, @R1               ; load Acc with value from register location
0x009A 22         RET 

; Jump Target - Callers: 0097               ; branch C = 0
0x009B BB FE 02   CJNE R3,  #0xFE, 0x00A0   ; check R3 = FE (-2)
0x009E E3         MOVX  A, @R1              ; load Acc with value from external register location
0x009F 22         RET 

; Jump Target - Callers: 009B               ; branch on R3 != -2 (xFE)
0x00A0 89 82      MOV  DPL, R1
0x00A2 8A 83      MOV  DPH, R2              ; load dptr from R1 and R2
0x00A4 E4         CLR A 
0x00A5 93         MOVC A, @A+DPTR           ; load Acc from dptr read of flash memory data
0x00A6 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;					READ with dpl dph pointer with adjustments from R1R2
; 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                                         
; Jump Target - Callers: 060D 06A0 0B27 02C3 
0x00A7 BB 01 0C   CJNE R3,  #0x01, 0x00B6   ; check state of R3 ?=1
0x00AA E5 82      MOV A,  DPL			
0x00AC 29         ADD A, R1 
0x00AD F5 82      MOV  DPL, A
0x00AF E5 83      MOV A,  DPH               ; adjust dptr with offsets from R1 and R2
0x00B1 3A         ADDC A, R2 
0x00B2 F5 83      MOV  DPH, A
0x00B4 E0         MOVX A, @DPTR             ; load Acc from dptr read external mem
0x00B5 22         RET                       

; Jump Target - Callers: 00A7 
0x00B6 50 06      JNC  0x00BE               ; branch on R3 != 1
0x00B8 E9         MOV A, R1 
0x00B9 25 82      ADD A,  DPL               ; adjust dpl with R1 offset
0x00BB F8         MOV R0, A 
0x00BC E6         MOV A, @R0                ; load Acc with value from register at address = dpl value
0x00BD 22         RET 

; Jump Target - Callers: 00B6 
0x00BE BB FE 06   CJNE R3,  #0xFE, 0x00C7   ; branch on C = 0, 
0x00C1 E9         MOV A, R1 
0x00C2 25 82      ADD A,  DPL               ; adjust dpl with R1 offset
0x00C4 F8         MOV R0, A 
0x00C5 E2         MOVX A, @R0               ; load Acc with value from ExtMem register at add = dpl value
0x00C6 22         RET 

; Jump Target - Callers: 00BE 
0x00C7 E5 82      MOV A,  DPL               ; branch on R3 != FE (-2)
0x00C9 29         ADD A, R1 
0x00CA F5 82      MOV  DPL, A
0x00CC E5 83      MOV A,  DPH
0x00CE 3A         ADDC A, R2                ; adjust dptr with R1 R2 offsets
0x00CF F5 83      MOV  DPH, A
0x00D1 E4         CLR A 
0x00D2 93         MOVC A, @A+DPTR           ; load Acc from dptr read of flash memory
0x00D3 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;					WRITE/STORE ROUTINE
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0717 0804 0601 0618 
0x00D4 BB 01 06   CJNE R3,  #0x01, 0x00DD   ; check state of R3 ?= 1
0x00D7 89 82      MOV  DPL, R1
0x00D9 8A 83      MOV  DPH, R2              ; load dptr from R1, R2 
0x00DB F0         MOVX @DPTR, A             ; write Acc to flash at dptr [R3 = 1]
0x00DC 22         RET 

; Jump Target - Callers: 00D4 
0x00DD 50 02      JNC  0x00E1               ; branch on R3 != 1
0x00DF F7         MOV @R1, A                ; write Acc to RAM register [C=1]
0x00E0 22         RET 

; Jump Target - Callers: 00DD 
0x00E1 BB FE 01   CJNE R3,  #0xFE, 0x00E5   ; branch on Carry not set C = 0
0x00E4 F3         MOVX @R1, A               ; write Acc to XRAM register [R3 = FE]

; Jump Target - Callers: 00E1 
0x00E5 22         RET                       ; branch on R3 != FE (-2)
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;					READ A, B
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 06C0               
0x00E6 BB 01 0A   CJNE R3,  #0x01, 0x00F3   
0x00E9 89 82      MOV  DPL, R1
0x00EB 8A 83      MOV  DPH, R2
0x00ED E0         MOVX A, @DPTR             
0x00EE F5 F0      MOV  B, A
0x00F0 A3         INC DPTR 
0x00F1 E0         MOVX A, @DPTR             ; load B and A from dptr read of external memory
0x00F2 22         RET 

; Jump Target - Callers: 00E6 
0x00F3 50 06      JNC  0x00FB
0x00F5 87 F0      MOV  B, @R1
0x00F7 09         INC R1 
0x00F8 E7         MOV A, @R1 		; from register pointed by R1
0x00F9 19         DEC R1 
0x00FA 22         RET 

; Jump Target - Callers: 00F3 
0x00FB BB FE 07   CJNE R3,  #0xFE, 0x0105
0x00FE E3         MOVX, A, @R1 
0x00FF F5 F0      MOV  B, A
0x0101 09         INC R1 
0x0102 E3         MOVX, A, @R1 		; from XRAM register pointed by R1
0x0103 19         DEC R1 
0x0104 22         RET 

; Jump Target - Callers: 00FB 
0x0105 89 82      MOV  DPL, R1
0x0107 8A 83      MOV  DPH, R2
0x0109 E4         CLR A 
0x010A 93         MOVC A, @A+DPTR 
0x010B F5 F0      MOV  B, A
0x010D 74 01      MOV A,  #0x01
0x010F 93         MOVC A, @A+DPTR           ; load A and B from dptr read from flash memory data
0x0110 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;                                           
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;					WRITES A, B
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 06B7               
0x0111 BB 01 0A   CJNE R3,  #0x01, 0x011E
0x0114 89 82      MOV  DPL, R1
0x0116 8A 83      MOV  DPH, R2
0x0118 F0         MOVX @DPTR, A 
0x0119 E5 F0      MOV A,  B
0x011B A3         INC DPTR 
0x011C F0         MOVX @DPTR, A             ; write A and B to flash at dptr
0x011D 22         RET 

; Jump Target - Callers: 0111 
0x011E 50 06      JNC  0x0126
0x0120 F7         MOV @R1, A 
0x0121 09         INC R1 
0x0122 A7 F0      MOV @R1,  B               ; write A and B to flash registers
0x0124 19         DEC R1 
0x0125 22         RET 

; Jump Target - Callers: 011E 
0x0126 BB FE 06   CJNE R3,  #0xFE, 0x012F
0x0129 F3         MOVX @R1, A 
0x012A E5 F0      MOV A,  B
0x012C 09         INC R1 
0x012D F3         MOVX @R1, A               ; write A and B to XRAM external registers
0x012E 19         DEC R1 

; Jump Target - Callers: 0126 
0x012F 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;                                 End of READ/WRITE R3 Carry routines
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				16-bit Math ?
;				Register difference with ORL
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;                                       ; what's this do?
; Jump Target - Callers: 0BA2 0702      ; Whoah... big batch of math (R0 - R7 all used here)
0x0130 EB         MOV A, R3 
0x0131 9F         SUBB A, R7            ; Subtract R7 from R3
0x0132 F5 F0      MOV  B, A             ; Put that in B
0x0134 EA         MOV A, R2 
0x0135 9E         SUBB A, R6            ; Subtract R6 from R2
0x0136 42 F0      ORL  B, A             ; Now take B OR A which is (R3-R7) LOR (R2-R6)->B
0x0138 E9         MOV A, R1 
0x0139 9D         SUBB A, R5            ; Subtract R5 from R1
0x013A 42 F0      ORL  B, A             ; Now take B OR A  ->B
0x013C E8         MOV A, R0             
0x013D 9C         SUBB A, R4            ; Subtract R4 from R0
0x013E 45 F0      ORL A,  B             ; Take A OR B now A contains the result of all these calcs
0x0140 22         RET                   ; Return (Result is in Accum)
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				END
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;                           Save gp registers with DPTR adjustment from R1,R2, state of R3 and Carry
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0376 
0x0141 BB 01 1A   CJNE R3,  #0x01, 0x015E   ; check state of R3 =1
0x0144 89 82      MOV  DPL, R1
0x0146 8A 83      MOV  DPH, R2
0x0148 D0 F0      POP  B
0x014A D0 E0      POP  ACC
0x014C F8         MOV R0, A 
0x014D D0 E0      POP  ACC
0x014F F9         MOV R1, A 
0x0150 D0 E0      POP  ACC
0x0152 FA         MOV R2, A 
0x0153 D0 E0      POP  ACC
0x0155 FB         MOV R3, A 
0x0156 E8         MOV A, R0 
0x0157 C0 E0      PUSH  ACC
0x0159 C0 F0      PUSH  B
0x015B 02 01 9F   LJMP  0x019F              ;skip over to continue writes [1]
;
; Jump Target - Callers: 0141 		; branch for R3 != 1
0x015E 50 16      JNC  0x0176               ; check C = 1
0x0160 E9         MOV A, R1 
0x0161 F8         MOV R0, A 
0x0162 D0 83      POP  DPH
0x0164 D0 82      POP  DPL
0x0166 D0 E0      POP  ACC
0x0168 F9         MOV R1, A 
0x0169 D0 E0      POP  ACC
0x016B FA         MOV R2, A 
0x016C D0 E0      POP  ACC
0x016E FB         MOV R3, A 
0x016F C0 82      PUSH  DPL
0x0171 C0 83      PUSH  DPH
0x0173 02 01 96   LJMP  0x0196              ; skip over to continue [2]
;
; Jump Target - Callers: 015E 		; branch on C = 0
0x0176 BB FE 16   CJNE R3,  #0xFE, 0x018F   ; check R3 = -2
0x0179 E9         MOV A, R1 
0x017A F8         MOV R0, A 
0x017B D0 83      POP  DPH
0x017D D0 82      POP  DPL
0x017F D0 E0      POP  ACC
0x0181 F9         MOV R1, A 
0x0182 D0 E0      POP  ACC
0x0184 FA         MOV R2, A 
0x0185 D0 E0      POP  ACC
0x0187 FB         MOV R3, A 
0x0188 C0 82      PUSH  DPL
0x018A C0 83      PUSH  DPH
0x018C 02 01 A8   LJMP  0x01A8              ; skip over to continue [3]
;
; Jump Target - Callers: 0176 
0x018F 22         RET                       ; exit if C =0 and R3 != -2
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				PROGRAM JUMP TO DPTR
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0A56               ; [Program jump to target location at DPTR ]
0x0190 8A 83      MOV  DPH, R2
0x0192 89 82      MOV  DPL, R1
0x0194 E4         CLR A 
0x0195 73         JMP @A+DPTR               ; program execution at target
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0173               ; continuation [2] 
0x0196 EB         MOV A, R3                 ; [Store R1,2,3 at R0 target registers]
0x0197 F6         MOV @R0, A 
0x0198 08         INC R0 
0x0199 EA         MOV A, R2 
0x019A F6         MOV @R0, A 
0x019B 08         INC R0 
0x019C E9         MOV A, R1 
0x019D F6         MOV @R0, A 
0x019E 22         RET                       ; [done]
;
; Jump Target - Callers: 015B               ; continuation [1] from skip over
0x019F EB         MOV A, R3 		; writes R3,R2,R1 to flash at dptr
0x01A0 F0         MOVX @DPTR, A 
0x01A1 A3         INC DPTR 
0x01A2 EA         MOV A, R2 
0x01A3 F0         MOVX @DPTR, A 
0x01A4 A3         INC DPTR 
0x01A5 E9         MOV A, R1 
0x01A6 F0         MOVX @DPTR, A 
0x01A7 22         RET                       ; [done]
;
; Jump Target - Callers: 018C               ; continuation [3]
0x01A8 EB         MOV A, R3 
0x01A9 F2         MOVX @R0, A 		; writes R3,R2,R1 to XRAM registers
0x01AA 08         INC R0 
0x01AB EA         MOV A, R2 
0x01AC F2         MOVX @R0, A 
0x01AD 08         INC R0 
0x01AE E9         MOV A, R1 
0x01AF F2         MOVX @R0, A 
0x01B0 22         RET                       ; [done]
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				End of DPTR Adjustment Routines
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				from 07A9
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 07A9               ;
0x01B1 E4         CLR A 
0x01B2 F5 10      MOV  X10h, A
0x01B4 F5 11      MOV  X11h, A
0x01B6 F5 16      MOV  X16h, A
0x01B8 75 17 00   MOV  X17h, #0x00
0x01BB 75 18 11   MOV  X18h, #0x11          ; load and clear registers, Reg 18 = 11
0x01BE FB         MOV R3, A 
0x01BF 7A 00      MOV R2,  #0x00
0x01C1 79 10      MOV R1,  #0x10
0x01C3 12 05 B7   LCALL  0x05B7		; [ todo
0x01C6 EF         MOV A, R7 
0x01C7 70 03      JNZ  0x01CC
0x01C9 02 02 53   LJMP  0x0253
;
; Jump Target - Callers: 01C7 		; branch
0x01CC 7B 00      MOV R3,  #0x00            
0x01CE 7A 00      MOV R2,  #0x00
0x01D0 79 0A      MOV R1,  #0x0A
0x01D2 12 06 79   LCALL  0x0679
0x01D5 EF         MOV A, R7 
0x01D6 60 7B      JZ  0x0253
0x01D8 12 00 16   LCALL  0x0016             ; sends #79 out the UART
0x01DB 7B 00      MOV R3,  #0x00
0x01DD 7A 00      MOV R2,  #0x00
0x01DF 79 0C      MOV R1,  #0x0C
0x01E1 7F 00      MOV R7,  #0x00
0x01E3 7E 00      MOV R6,  #0x00
0x01E5 7D 00      MOV R5,  #0x00
0x01E7 7C 00      MOV R4,  #0x00
0x01E9 12 09 F7   LCALL  0x09F7		; clear 5D-60 counter, Read UART, store and send back out
0x01EC EF         MOV A, R7 
0x01ED 64 01      XRL A,  #0x01
0x01EF 70 62      JNZ  0x0253
0x01F1 FB         MOV R3, A 
0x01F2 7A 00      MOV R2,  #0x00
0x01F4 79 0D      MOV R1,  #0x0D
0x01F6 75 24 40   MOV  X24h, #0x40
0x01F9 75 23 28   MOV  X23h, #0x28
0x01FC 75 22 BA   MOV  X22h, #0xBA
0x01FF F5 21      MOV  X21h, A
0x0201 12 08 D7   LCALL  0x08D7
0x0204 85 0C 29   MOV  X29h, X0Ch
0x0207 AD 0C      MOV R5,  X0Ch
0x0209 12 02 F3   LCALL  0x02F3
0x020C 8F 12      MOV  X12h, R7
0x020E E5 12      MOV A,  X12h
0x0210 B4 01 2A   CJNE A,  #0x01, 0x023D
0x0213 75 16 00   MOV  X16h, #0x00
0x0216 75 17 00   MOV  X17h, #0x00
0x0219 75 18 11   MOV  X18h, #0x11
0x021C 85 0A 19   MOV  X19h, X0Ah
0x021F 85 0B 1A   MOV  X1Ah, X0Bh
0x0222 85 0D 1B   MOV  X1Bh, X0Dh
0x0225 85 0E 1C   MOV  X1Ch, X0Eh
0x0228 85 0F 1D   MOV  X1Dh, X0Fh
0x022B 85 0C 1E   MOV  X1Eh, X0Ch
0x022E 7B 00      MOV R3,  #0x00
0x0230 7A 00      MOV R2,  #0x00
0x0232 79 10      MOV R1,  #0x10
0x0234 12 03 89   LCALL  0x0389			;[]
0x0237 BF 02 19   CJNE R7,  #0x02, 0x0253
0x023A 02 00 16   LJMP  0x0016              ; send #79 out UART
;
; Jump Target - Callers: 0210 
0x023D E5 12      MOV A,  X12h
0x023F B4 04 11   CJNE A,  #0x04, 0x0253
0x0242 75 17 40   MOV  X17h, #0x40
0x0245 75 16 28   MOV  X16h, #0x28
0x0248 75 15 BA   MOV  X15h, #0xBA
0x024B 75 14 00   MOV  X14h, #0x00
0x024E AF 0C      MOV R7,  X0Ch
0x0250 12 09 52   LCALL  0x0952
;
; Jump Target - Callers: 01D6 01EF 023F 0237 01C9 
0x0253 E4         CLR A 
0x0254 F5 10      MOV  X10h, A
0x0256 F5 11      MOV  X11h, A
0x0258 12 00 1E   LCALL  0x001E               ; send #1F out UART
0x025B 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;					07A6
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 07A6 
0x025C E4         CLR A 
0x025D F5 0E      MOV  X0Eh, A
0x025F F5 0F      MOV  X0Fh, A
0x0261 F5 16      MOV  X16h, A
0x0263 75 17 00   MOV  X17h, #0x00
0x0266 75 18 0F   MOV  X18h, #0x0F              ; load Reg 18 = 0F
0x0269 FB         MOV R3, A 
0x026A 7A 00      MOV R2,  #0x00
0x026C 79 0E      MOV R1,  #0x0E
0x026E 12 05 B7   LCALL  0x05B7
0x0271 EF         MOV A, R7 
0x0272 60 76      JZ  0x02EA
0x0274 7B 00      MOV R3,  #0x00
0x0276 7A 00      MOV R2,  #0x00
0x0278 79 0A      MOV R1,  #0x0A
0x027A 12 08 EF   LCALL  0x08EF
0x027D 7C 00      MOV R4,  #0x00
0x027F 12 09 F7   LCALL  0x09F7		; clear 5D-60 counter, Read UART, store and send back out
0x0282 EF         MOV A, R7 
0x0283 64 01      XRL A,  #0x01
0x0285 70 63      JNZ  0x02EA
0x0287 E5 0A      MOV A,  X0Ah
0x0289 C3         CLR C 
0x028A 94 0A      SUBB A,  #0x0A
0x028C 50 5C      JNC  0x02EA
0x028E 7A 00      MOV R2,  #0x00
0x0290 79 0B      MOV R1,  #0x0B
0x0292 12 08 C8   LCALL  0x08C8
0x0295 85 0A 29   MOV  X29h, X0Ah
0x0298 AD 0A      MOV R5,  X0Ah
0x029A 12 02 F3   LCALL  0x02F3
0x029D EF         MOV A, R7 
0x029E 64 01      XRL A,  #0x01
0x02A0 70 48      JNZ  0x02EA
0x02A2 75 11 01   MOV  X11h, #0x01
0x02A5 F5 10      MOV  X10h, A
;
; Jump Target - Callers: 02DB 
0x02A7 E5 10      MOV A,  X10h          ; loop
0x02A9 C3         CLR C 
0x02AA 95 0A      SUBB A,  X0Ah
0x02AC 50 2F      JNC  0x02DD
0x02AE 75 15 00   MOV  X15h, #0x00
0x02B1 75 16 00   MOV  X16h, #0x00
0x02B4 75 17 0F   MOV  X17h, #0x0F
0x02B7 AB 0B      MOV R3,  X0Bh
0x02B9 AA 0C      MOV R2,  X0Ch
0x02BB A9 0D      MOV R1,  X0Dh
0x02BD 85 10 82   MOV  DPL, X10h        ; DPTR loaded = 00 xx   , ExtMem ?
0x02C0 75 83 00   MOV  DPH, #0x00
0x02C3 12 00 A7   LCALL  0x00A7         ; read some data based upon R3=(0B) and Carry=1 Flag state
0x02C6 F5 18      MOV  X18h, A          ; and store it in Reg (18)
0x02C8 7B 00      MOV R3,  #0x00
0x02CA 7A 00      MOV R2,  #0x00
0x02CC 79 0E      MOV R1,  #0x0E
0x02CE 12 08 8B   LCALL  0x088B         ;
0x02D1 EF         MOV A, R7 
0x02D2 64 01      XRL A,  #0x01
0x02D4 60 03      JZ  0x02D9
0x02D6 E4         CLR A 
0x02D7 F5 11      MOV  X11h, A
;
; Jump Target - Callers: 02D4 
0x02D9 05 10      INC  X10h
0x02DB 80 CA      SJMP  0x02A7          ; go back into loop
;
; Jump Target - Callers: 02AC 
0x02DD E5 11      MOV A,  X11h
0x02DF 60 09      JZ  0x02EA
0x02E1 12 00 16   LCALL  0x0016
0x02E4 E4         CLR A 
0x02E5 F5 0E      MOV  X0Eh, A
0x02E7 F5 0F      MOV  X0Fh, A
0x02E9 22         RET 
;
; Jump Target - Callers: 0272 0285 028C 02A0 02DF 
0x02EA E4         CLR A 
0x02EB F5 0E      MOV  X0Eh, A
0x02ED F5 0F      MOV  X0Fh, A
0x02EF 12 00 1E   LCALL  0x001E                 ; send #1F out UART
0x02F2 22         RET 
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
; Jump Target - Callers: 05E2 068C 0209 029A 
0x02F3 8B 1D      MOV  X1Dh, R3
0x02F5 8A 1E      MOV  X1Eh, R2
0x02F7 89 1F      MOV  X1Fh, R1
0x02F9 8D 20      MOV  X20h, R5
0x02FB 85 29 2C   MOV  X2Ch, X29h
0x02FE E5 20      MOV A,  X20h
0x0300 24 01      ADD A,  #0x01
0x0302 FF         MOV R7, A 
0x0303 E4         CLR A 
0x0304 33         RLC A 
0x0305 FE         MOV R6, A 
0x0306 D3         SETB C 
0x0307 EF         MOV A, R7 
0x0308 94 20      SUBB A,  #0x20
0x030A EE         MOV A, R6 
0x030B 94 00      SUBB A,  #0x00
0x030D 40 03      JC  0x0312
0x030F 7F 04      MOV R7,  #0x04            ; load R7 = #04 and exit
0x0311 22         RET
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
;
; Jump Target - Callers: 030D 
0x0312 AF 24      MOV R7,  X24h
0x0314 AE 23      MOV R6,  X23h
0x0316 AD 22      MOV R5,  X22h
0x0318 AC 21      MOV R4,  X21h
0x031A 12 03 7C   LCALL  0x037C		; 
0x031D 60 03      JZ  0x0322
0x031F 7F 02      MOV R7,  #0x02            ; R7 = 2
0x0321 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 031D 
0x0322 85 2B 3C   MOV  X3Ch, X2Bh   ;copy RAM 0x2B (Tx Flag) to RAM 0x3C
0x0325 E5 29      MOV A,  X29h      ;Load accum with value from RAM 0x29
0x0327 65 2B      XRL A,  X2Bh      ;XOR that with RAM 0x2B (TX Flag)
0x0329 F5 2C      MOV  X2Ch, A      ;Store result into RAM 0x2C
0x032B 75 2A 01   MOV  X2Ah, #0x01  ;Set RAM 0x2A to 1 (2A is where byte received from UART is stored)
;
; loop - Callers: 035B 
0x032E E5 20      MOV A,  X20h      ;Copy value from RAM 0x20 to Accum
0x0330 24 01      ADD A,  #0x01     ;Add one to it
0x0332 FF         MOV R7, A         ;Store it in R7
0x0333 E4         CLR A             ;Clear accum
0x0334 33         RLC A             ;Rotate accum left one - In this case, rotate Carry flag into accum
0x0335 FE         MOV R6, A         ;Store accum into R6 (R6 is now value from carry flag)
0x0336 C3         CLR C             ;Clear the carry flag
0x0337 E5 2A      MOV A,  X2Ah      ;Get value from RAM 0x2A (UART rx'd char) and store to accum
0x0339 9F         SUBB A, R7        ;Subtract R7 from Accum (because of next clear this is used just to influence carry flag)
0x033A E4         CLR A             ;Clear accumulator (carry flag still set if R7 was larger than accum)
0x033B 9E         SUBB A, R6        ;Subtract R6 from newly cleared accum. Carry flag is part of this though.
0x033C 50 1F      JNC  0x035D       ;Branch if carry not set (Only if value from RAM 0x2A was larger than R7 and R6 was zero?)
0x033E AF 28      MOV R7,  X28h     
0x0340 AE 27      MOV R6,  X27h     
0x0342 AD 26      MOV R5,  X26h     
0x0344 AC 25      MOV R4,  X25h     
0x0346 12 03 7C   LCALL  0x037C     ;call not jump so code returns to next line
0x0349 60 03      JZ  0x034E        ;if call resulted in accum being zero then branch
0x034B 7F 02      MOV R7,  #0x02    ;Otherwise set R7 to 2 and return
0x034D 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0349       ;call above returned zero so do this.
0x034E 74 3C      MOV A,  #0x3C     
0x0350 25 2A      ADD A,  X2Ah
0x0352 F8         MOV R0, A 
0x0353 A6 2B      MOV @R0,  X2Bh
0x0355 E5 2B      MOV A,  X2Bh
0x0357 62 2C      XRL  X2Ch, A
0x0359 05 2A      INC  X2Ah
0x035B 80 D1      SJMP  0x032E	; back to loop
;
; Jump Target - Callers: 033C 	; C =0
0x035D E5 2C      MOV A,  X2Ch      ; Grab RAM 0x2C (flag to set whether to forward bytes on UART)
0x035F 60 03      JZ  0x0364        ; Jump if accum is zero (if we're not forwarding bytes on UART)
0x0361 7F 03      MOV R7,  #0x03    ; Otherwise, set R7 to 3 and return
0x0363 22         RET
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
;
; Jump Target - Callers: 035F 
0x0364 7B 00      MOV R3,  #0x00
0x0366 7A 00      MOV R2,  #0x00
0x0368 79 3C      MOV R1,  #0x3C
0x036A C0 03      PUSH  R3        ;R3
0x036C C0 02      PUSH  R2        ;R2
0x036E C0 01      PUSH  R1        ;R1
0x0370 AB 1D      MOV R3,  X1Dh
0x0372 AA 1E      MOV R2,  X1Eh
0x0374 A9 1F      MOV R1,  X1Fh
0x0376 12 01 41   LCALL  0x0141
0x0379 7F 01      MOV R7,  #0x01    ;Set R7 to 1 and return
0x037B 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 031A 0346 
0x037C 7B 00      MOV R3,  #0x00
0x037E 7A 00      MOV R2,  #0x00
0x0380 79 2B      MOV R1,  #0x2B
0x0382 12 09 F7   LCALL  0x09F7		; clear 5D-60 counter, Read UART, store and send back out 
0x0385 EF         MOV A, R7 
0x0386 64 01      XRL A,  #0x01
0x0388 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0234 
0x0389 8B 13      MOV  X13h, R3
0x038B 8A 14      MOV  X14h, R2
0x038D 89 15      MOV  X15h, R1
0x038F E4         CLR A 
0x0390 F5 1F      MOV  X1Fh, A
;
; loop - Callers: 03C4 			;loop
0x0392 E5 19      MOV A,  X19h
0x0394 C3         CLR C 
0x0395 13         RRC A 
0x0396 FF         MOV R7, A 
0x0397 E5 1F      MOV A,  X1Fh
0x0399 90 0B E5   MOV DPTR,  #0x0BE5            ; read 6 state table
0x039C 93         MOVC A, @A+DPTR 
0x039D FD         MOV R5, A 
0x039E 7C 00      MOV R4,  #0x00
0x03A0 6F         XRL A, R7 
0x03A1 70 01      JNZ  0x03A4
0x03A3 E4         CLR A 
;
; Jump Target - Callers: 03A1 
0x03A4 60 17      JZ  0x03BD
0x03A6 AF 1E      MOV R7,  X1Eh
0x03A8 7E 00      MOV R6,  #0x00
0x03AA E5 1A      MOV A,  X1Ah
0x03AC 25 1E      ADD A,  X1Eh
0x03AE CF         XCH A, R7 
0x03AF EE         MOV A, R6 
0x03B0 35 19      ADDC A,  X19h
0x03B2 CF         XCH A, R7 
0x03B3 24 FF      ADD A,  #0xFF
0x03B5 CF         XCH A, R7 
0x03B6 34 FF      ADDC A,  #0xFF
0x03B8 C3         CLR C 
0x03B9 13         RRC A 
0x03BA B5 05 03   CJNE A,  R5, 0x03C0
;
; Jump Target - Callers: 03A4 
0x03BD 7F 03      MOV R7,  #0x03
0x03BF 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 03BA 
0x03C0 05 1F      INC  X1Fh
0x03C2 E5 1F      MOV A,  X1Fh
0x03C4 B4 07 CB   CJNE A,  #0x07, 0x0392		; back to loop
0x03C7 E4         CLR A 
0x03C8 F5 1F      MOV  X1Fh, A
;
; loop - Callers: 0417 
0x03CA E5 1F      MOV A,  X1Fh              ; loop
0x03CC C3         CLR C 
0x03CD 95 1E      SUBB A,  X1Eh
0x03CF 50 48      JNC  0x0419
0x03D1 85 16 23   MOV  X23h, X16h
0x03D4 85 17 24   MOV  X24h, X17h
0x03D7 85 18 25   MOV  X25h, X18h
0x03DA 7E 00      MOV R6,  #0x00
0x03DC E5 1A      MOV A,  X1Ah
0x03DE 25 1F      ADD A,  X1Fh
0x03E0 F5 27      MOV  X27h, A		; loading value to become dpl
0x03E2 EE         MOV A, R6 
0x03E3 35 19      ADDC A,  X19h
0x03E5 F5 26      MOV  X26h, A		; and dph
0x03E7 12 0B 1B   LCALL  0x0B1B		;
0x03EA F5 28      MOV  X28h, A
0x03EC 75 29 01   MOV  X29h, #0x01
0x03EF AB 13      MOV R3,  X13h
0x03F1 AA 14      MOV R2,  X14h
0x03F3 A9 15      MOV R1,  X15h
0x03F5 12 09 7E   LCALL  0x097E		;
0x03F8 EF         MOV A, R7 
0x03F9 70 03      JNZ  0x03FE
0x03FB 7F 03      MOV R7,  #0x03
0x03FD 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 03F9 
0x03FE 7E 00      MOV R6,  #0x00
0x0400 E5 1A      MOV A,  X1Ah
0x0402 25 1F      ADD A,  X1Fh
0x0404 FF         MOV R7, A 
0x0405 EE         MOV A, R6 
0x0406 35 19      ADDC A,  X19h
0x0408 FE         MOV R6, A 
0x0409 12 0B 78   LCALL  0x0B78		; read at r6r7 dptr, return in R7
0x040C 12 0B 1B   LCALL  0x0B1B		;
0x040F 6F         XRL A, R7 
0x0410 60 03      JZ  0x0415
0x0412 7F 03      MOV R7,  #0x03
0x0414 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0410 
0x0415 05 1F      INC  X1Fh
0x0417 80 B1      SJMP  0x03CA		; up to loop
;
; Jump Target - Callers: 03CF 
0x0419 7F 02      MOV R7,  #0x02
0x041B 22         RET
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				RESET
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Reset:					; starts here
0x041C 78 7F      MOV R0,  #0x7F    	;
0x041E E4         CLR A             	;
;
ClearRam:				; loop to clear stack then set pointer and jump to init section
0x041F F6         MOV @R0, A        	;
0x0420 D8 FD      DJNZ R0,  ClearRam	;
0x0422 75 81 69   MOV  SP, #0x69    	;Stack pointer  0x69, this register will be selector for main branch
0x0425 02 04 63   LJMP  StartInitMem      	;Initialise some memory locations
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - — — — - - - - - — - - — - - - - - - - - - - -  
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - — — — - - - - - — - - — - - - - - - - - - - -  
;				Return from StartInitMem
;
DoneInitMem: Callers: 046A       
0x0428 02 0A FB   LJMP  0x0AFB      	; jump to the hardware init routines
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - — — — - - - - - — - - — - - - - - - - - - - -  
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - — — — - - - - - — - - — - - - - - - - - - - -  
;
;					memory fill locations and schemes
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; reader with R0,C  address : 0481   	; branch for <40 bytes or =80 bytes to move 
0x042B E4         CLR A 
0x042C 93         MOVC A, @A+DPTR 	; read next byte
0x042D A3         INC DPTR 		; dptr+1
0x042E F8         MOV R0, A 		; store it in R0, an 8-bit address pointer
;					; fall thru
; Loop on R7	: 0439		       	; loop using R7 counter
0x042F E4         CLR A 
0x0430 93         MOVC A, @A+DPTR 	; read the next byte and inc dptr
0x0431 A3         INC DPTR 
0x0432 40 03      JC  0x0437		; check Carry  C? 
0x0434 F6         MOV @R0, A 		; if C=0, then store in stack at R0 Int register location
0x0435 80 01      SJMP  0x0438		; and skip over movx
;
; branch  - Callers: 0432 
0x0437 F2         MOVX @R0, A 		; if C=1 store in ExtMem at R0 Ext address location
;
; continue - Callers: 0435 
0x0438 08         INC R0 			; bump address to next location
0x0439 DF F4      DJNZ R7,  0x042F	; repeat this loop R7 times
0x043B 80 29      SJMP  0x0466          	; when countdown done go back to reader section check for more
;
;
;					; another location and fill scheme
; branch on C set - Callers: 0483    	; branch when C=1 from reader (data >#80; R7 counter loop 0457)
0x043D E4         CLR A 			
0x043E 93         MOVC A, @A+DPTR 	; read next byte and bump dptr
0x043F A3         INC DPTR 
0x0440 F8         MOV R0, A 		; store it in R0 (address location pointer)
0x0441 54 07      ANL A,  #0x07		; mask 07 (low 3 bits) so value will be 0 to 7
0x0443 24 0C      ADD A,  #0x0C		; add offset to reach PC table
0x0445 C8         XCH A, R0 		; store back into location pointer R0 and
0x0446 C3         CLR C 			; examine the byte
0x0447 33         RLC A 			; multiply data by 2 with Carry (C set if >80
0x0448 C4         SWAP A 			; nibble swap
0x0449 54 0F      ANL A,  #0x0F		; keep lower nib and clear upper
0x044B 44 20      ORL A,  #0x20		; set bit.5 (in upper nib) 0010 xxxx
0x044D C8         XCH A, R0 		; store the manipulated data in R0 and recover PC offset
0x044E 83         MOVC A, @A+PC         ; read from PC table at 045B (PC + offset)
0x044F 40 04      JC  0x0455		; check C?
0x0451 F4         CPL A 			; if C=0 then compliment the PC data
0x0452 56         ANL A, @R0 		; and mask ^ bits with the @R0 register value
0x0453 80 01      SJMP  0x0456		; skip over
;
; Jump Target - Callers: 044F 
0x0455 46         ORL A, @R0 		; if C=1 then use @R0 pointed register data to set bits of PC value
;
; Jump Target - Callers: 0453 
0x0456 F6         MOV @R0, A 		; then store resultant in register pointed to by R0 (new @R0 value)
0x0457 DF E4      DJNZ R7,  0x043D	; repeat R7 times
0x0459 80 0B      SJMP  0x0466          ; sjump back to startinitmem reader section
;
; Data table for PC-based read above in 044E , obscure usage
0x045B            0x01
0x045C            0x02
0x045D            0x04
0x045E            0x08
0x045F            0x10
0x0460            0x20 
0x0461            0x40 
0x0462            0x80
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				StartInitMem
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
StartInitMem: Callers: 0425           	; "StartInitMem"  various memory locations and schemes to fill
0x0463 90 0B 5F   MOV DPTR,  #0x0B5F        ;Set DPTR to 0B5F #InitCodeTable 
;                                           ; 05 5D 00 00 ... 
;
; Jump Target - Callers: 043B 0459 04A6	; reader dptr data and preload RAM locations
0x0466 E4         CLR A                 
0x0467 7E 01      MOV R6,  #0x01        	;Set loop counter R6 to 1
0x0469 93         MOVC A, @A+DPTR       	;grab data
0x046A 60 BC      JZ  DoneInitMem 0x0428  ;EXIT Condition: If data=0 then exit @ 0x428
0x046C A3         INC DPTR              	;dptr+1
0x046D FF         MOV R7, A             	;Store current accum to R7 (loop counter)
;					; examine the data 
0x046E 54 3F      ANL A,  #0x3F         ;Accum = Accum & 3F               mask (low 6bits)
0x0470 30 E5 09   JNB  ACC.5, 0x047C    ; branch if data is less than #20
0x0473 54 1F      ANL A,  #0x1F         ;if data was >#20 then mask down to 1F (low 5bits)
0x0475 FE         MOV R6, A             ;Save new R6 (loop counter =< 1F, (will be reading 32-bytes or less)
0x0476 E4         CLR A                 ;
0x0477 93         MOVC A, @A+DPTR       ;Grab next byte (points to the memory location to fill)
0x0478 A3         INC DPTR              ;DPTR+1
0x0479 60 01      JZ  0x047C            ;If grabbed value was 0 then branch to 0x47C (invalid add or EOD)
0x047B 0E         INC R6 		   	; if not 0 then inc loop counter
;
; branch - Callers: 0470 0479 		;fall thru or branches above, data < 20 or =0
0x047C CF         XCH A, R7             ;examine counter from R7 and store location byte in R7
0x047D 54 C0      ANL A,  #0xC0         ;Save only top two bits mask (top 2bits)
0x047F 25 E0      ADD A,  ACC           ;Multiply the accum by two (add it to itself)
0x0481 60 A8      JZ  0x042B            ;If accum is 0 then branch to 0x42B (only true if <40 or =80)
;					; check carry?
0x0483 40 B8      JC  0x043D            ;If C=1 (data was >80) then branch to 0x43D [?obscure meaning]
;					;else C=0 fall thru (then location byte in R7 is 2nd counter)
;					; indicates to fill from flash to external 16-bit addresses
0x0485 E4         CLR A                 ;If data was less than 80 but greater than 40
0x0486 93         MOVC A, @A+DPTR       ;Grab next byte
0x0487 A3         INC DPTR              ;DPTR+1
0x0488 FA         MOV R2, A             ;Save to R2
0x0489 E4         CLR A                 ;
0x048A 93         MOVC A, @A+DPTR       ;Grab next byte
0x048B A3         INC DPTR              ;DPTR+1
0x048C F8         MOV R0, A             ;Save to R0 ; [this is loading 16-bit pointer address]
;					;fall thru
; loop - from: 04A2 04A4		      ;loop to move memory data values R7, R6 times
0x048D E4         CLR A                 ;clear accum
0x048E 93         MOVC A, @A+DPTR       ;grab byte at DPTR (Flash)
0x048F A3         INC DPTR              ;Increment DPTR
0x0490 C8         XCH A, R0             ;Swap R0 and Accum
0x0491 C5 82      XCH A,  DPL           ;Swap Accum and low byte of DPTR
0x0493 C8         XCH A, R0             ;Swap Accum and R0
0x0494 CA         XCH A, R2             ;Swap Accum and R2
0x0495 C5 83      XCH A,  DPH           ;Swap Accum and high byte of DPTR
0x0497 CA         XCH A, R2             ;Swap Accum and R2
0x0498 F0         MOVX @DPTR, A         ;store byte at R2:R0 DPTR External? (RAM)
0x0499 A3         INC DPTR              ;Increment DPTR
0x049A C8         XCH A, R0             ;Swap Accum and R0
0x049B C5 82      XCH A,  DPL           ;Swap Accum and low byte of DPTR
0x049D C8         XCH A, R0             ;Swap Accum and R0
0x049E CA         XCH A, R2             ;Swap Accum and R2
0x049F C5 83      XCH A,  DPH           ;Swap Accum and high byte of DPTR
0x04A1 CA         XCH A, R2             ;Swap Accum and R2
0x04A2 DF E9      DJNZ R7,  0x048D      ;Decrement R7 and loop if not zero 
0x04A4 DE E7      DJNZ R6,  0x048D      ;Decrement R6 and loop if not zero
0x04A6 80 BE      SJMP  0x0466          ;go back up into reader section and check for more 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - — — — - - - - - — - - — - - - - - - - - - - -
;				END
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				16-bit math to calc dptr values 0E0F return with R6R7
;				0AB1, 073B
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0AB1 073B      ;seems to save registers to storage then init them to new values
0x04A8 8C 0C      MOV  X0Ch, R4         ;PUSH gp R4 R5 to 0x0C 0D
0x04AA 8D 0D      MOV  X0Dh, R5         
0x04AC AD 07      MOV R5, R7            ;POP R6 R7 to R4 R5
0x04AE AC 06      MOV R4, R6            
0x04B0 8A 0E      MOV  X0Eh, R2         ;PUSH R2 R3 to 0x0E 0F
0x04B2 8B 0F      MOV  X0Fh, R3         
0x04B4 E4         CLR A 
0x04B5 F9         MOV R1, A             ;Clear R1
;
; Jump Target - Callers: 0515 	; 16-bit subtraction
0x04B6 D3         SETB C                ;C = 1 (usually carry is cleared before SUBB)
0x04B7 ED         MOV A, R5             ;Set accum to value in R5 (potentially from R7 if coming from 0x4A8)
0x04B8 95 0D      SUBB A,  X0Dh         ; subb = A - Carry - Value 
0x04BA EC         MOV A, R4             ;Set accum to value in R4 (potentially from R6 if coming from 0x4A8)
0x04BB 95 0C      SUBB A,  X0Ch         
0x04BD 50 58      JNC  0x0517  		; check C    EXIT      
0x04BF AF 05      MOV R7,  R5          
0x04C1 AE 04      MOV R6,  R4          
0x04C3 12 0B 78   LCALL  0x0B78         ; get FLASH dptr r6r7, return in R7
0x04C6 EF         MOV A, R7
0x04C7 7B 00      MOV R3,  #0x00
0x04C9 FA         MOV R2, A 
0x04CA ED         MOV A, R5 
0x04CB 24 01      ADD A,  #0x01
0x04CD FF         MOV R7, A 
0x04CE E4         CLR A 
0x04CF 3C         ADDC A, R4 
0x04D0 FE         MOV R6, A 
0x04D1 12 0B 78   LCALL  0x0B78         ; get FLASH dptr r6r7, return in R7
0x04D4 7E 00      MOV R6,  #0x00
0x04D6 EB         MOV A, R3 
0x04D7 2F         ADD A, R7 
0x04D8 F5 11      MOV  X11h, A
0x04DA EE         MOV A, R6 
0x04DB 3A         ADDC A, R2 
0x04DC F5 10      MOV  X10h, A
0x04DE C3         CLR C 
0x04DF 74 FF      MOV A,  #0xFF
0x04E1 95 11      SUBB A,  X11h
0x04E3 FF         MOV R7, A 
0x04E4 74 FF      MOV A,  #0xFF
0x04E6 95 10      SUBB A,  X10h
0x04E8 FE         MOV R6, A 
0x04E9 C3         CLR C 
0x04EA EF         MOV A, R7 
0x04EB 95 0F      SUBB A,  X0Fh
0x04ED EE         MOV A, R6 
0x04EE 95 0E      SUBB A,  X0Eh
0x04F0 40 04      JC  0x04F6
0x04F2 7F 00      MOV R7,  #0x00
0x04F4 80 02      SJMP  0x04F8
;
; Jump Target - Callers: 04F0 
0x04F6 7F 01      MOV R7,  #0x01
;
; Jump Target - Callers: 04F4 
0x04F8 A9 07      MOV R1,  R7
0x04FA E5 0F      MOV A,  X0Fh
0x04FC 25 11      ADD A,  X11h
0x04FE FF         MOV R7, A 
0x04FF E5 0E      MOV A,  X0Eh
0x0501 35 10      ADDC A,  X10h
0x0503 FE         MOV R6, A 
0x0504 E9         MOV A, R1 
0x0505 7A 00      MOV R2,  #0x00
0x0507 2F         ADD A, R7 
0x0508 F5 0F      MOV  X0Fh, A
0x050A EA         MOV A, R2 
0x050B 3E         ADDC A, R6 
0x050C F5 0E      MOV  X0Eh, A
0x050E 74 02      MOV A,  #0x02
0x0510 2D         ADD A, R5 
0x0511 FD         MOV R5, A 
0x0512 E4         CLR A 
0x0513 3C         ADDC A, R4 
0x0514 FC         MOV R4, A 
0x0515 80 9F      SJMP  0x04B6		; loops back up
;
; EXIT Target - Callers: 04BD 			; EXIT branch for C = 0 from 16-bit subb
0x0517 63 0F FF   XRL  X0Fh, #0xFF
0x051A 63 0E FF   XRL  X0Eh, #0xFF		; flip bits in 0E 0F  1's comp
0x051D E5 0F      MOV A,  X0Fh
0x051F B4 FF 0B   CJNE A,  #0xFF, 0x052D
0x0522 E5 0E      MOV A,  X0Eh
0x0524 B4 FF 06   CJNE A,  #0xFF, 0x052D		; evaluate 0E only if 0F was = 0
0x0527 74 A5      MOV A,  #0xA5
0x0529 F5 0E      MOV  X0Eh, A
0x052B F5 0F      MOV  X0Fh, A			; load #A5 into 0E 0F if both were = 0
;
; Jump Target - Callers: 051F 0524 
0x052D AE 0E      MOV R6,  X0Eh			; otherwise keep 1's comp values in R6 R7
0x052F AF 0F      MOV R7,  X0Fh
0x0531 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				END
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				0A23
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0A23 
0x0532 E4         CLR A 
0x0533 F5 09      MOV  X09h, A      ;Null out X09-X0B RAM locations
0x0535 F5 0A      MOV  X0Ah, A
0x0537 F5 0B      MOV  X0Bh, A
0x0539 7F 01      MOV R7,  #0x01
0x053B 12 00 56   LCALL  0x0056     ; Move R7 to RAM 0x68 (So set it to 1)
;
; Jump Target - Callers: 05AF 05A9 0584 056A 
0x053E E5 09      MOV A,  X09h
0x0540 C3         CLR C 
0x0541 94 80      SUBB A,  #0x80
0x0543 50 6F      JNC  0x05B4
0x0545 7A 00      MOV R2,  #0x00
0x0547 79 08      MOV R1,  #0x08
0x0549 12 0B 8F   LCALL  0x0B8F		;zzz
0x054C 12 06 D2   LCALL  0x06D2		; Routine to read UART, store byte in x66, and send it out UART
0x054F 8F 0C      MOV  X0Ch, R7
0x0551 E5 0C      MOV A,  X0Ch
0x0553 64 01      XRL A,  #0x01
0x0555 70 54      JNZ  0x05AB
0x0557 05 09      INC  X09h
0x0559 AF 0B      MOV R7,  X0Bh
0x055B 05 0B      INC  X0Bh
0x055D EF         MOV A, R7 
0x055E 90 0B 74   MOV DPTR,  #0x0B74            ; 4 data values, 81 8A 85 88 (these are bytes to send out UART
0x0561 93         MOVC A, @A+DPTR 		; to indicate to other bmb to ignore ?
0x0562 B5 08 0A   CJNE A,  X08h, 0x056F	; compare data = (08)?  [where does 08 get loaded-either R6 or R3
0x0565 E5 0B      MOV A,  X0Bh		; if so then check (0B)
0x0567 C3         CLR C  			; always clear C before Subtraction
0x0568 94 04      SUBB A,  #0x04		; A= (0B)-#04-C
0x056A 40 D2      JC  0x053E		; if C=1 then repeat this loop (means (0B<4, there are 4 table values
0x056C 7F 05      MOV R7,  #0x05          ; else if C=0, load R7 = 5 and exit
0x056E 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0562 
0x056F E4         CLR A 
0x0570 F5 0B      MOV  X0Bh, A
0x0572 AF 0A      MOV R7,  X0Ah
0x0574 05 0A      INC  X0Ah
0x0576 EF         MOV A, R7 
0x0577 90 0B 6C   MOV DPTR,  #0x0B6C            ; "BOOTload"
0x057A 93         MOVC A, @A+DPTR 
0x057B 65 08      XRL A,  X08h
0x057D 70 27      JNZ  0x05A6
0x057F E5 0A      MOV A,  X0Ah
0x0581 C3         CLR C 
0x0582 94 08      SUBB A,  #0x08
0x0584 40 B8      JC  0x053E
0x0586 E4         CLR A 
0x0587 75 17 42   MOV  X17h, #0x42
0x058A 75 16 EF   MOV  X16h, #0xEF
0x058D F5 15      MOV  X15h, A
0x058F F5 14      MOV  X14h, A
0x0591 7F 01      MOV R7,  #0x01
0x0593 12 09 52   LCALL  0x0952
0x0596 EF         MOV A, R7 
0x0597 64 02      XRL A,  #0x02
0x0599 60 03      JZ  0x059E                ; compare
0x059B 7F 03      MOV R7,  #0x03            ; load R7 = 3 and exit
0x059D 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0599 
0x059E E4         CLR A                     ; branch
0x059F FF         MOV R7, A 
0x05A0 12 00 56   LCALL  0x0056             ; store R7 =0 in Reg 68
0x05A3 7F 06      MOV R7,  #0x06            ; load R7 = 6 and exit
0x05A5 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 057D 
0x05A6 E4         CLR A 
0x05A7 F5 0A      MOV  X0Ah, A
0x05A9 80 93      SJMP  0x053E
;
; Jump Target - Callers: 0555 
0x05AB E5 0C      MOV A,  X0Ch
0x05AD 64 02      XRL A,  #0x02
0x05AF 70 8D      JNZ  0x053E
0x05B1 7F 02      MOV R7,  #0x02
0x05B3 22         RET
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
; Jump Target - Callers: 0543 
0x05B4 7F 03      MOV R7,  #0x03
0x05B6 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				01C3, 026E
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 01C3 026E 		;
0x05B7 8B 13      MOV  X13h, R3
0x05B9 8A 14      MOV  X14h, R2
0x05BB 89 15      MOV  X15h, R1
0x05BD 7A 00      MOV R2,  #0x00
0x05BF 79 19      MOV R1,  #0x19
0x05C1 12 08 E2   LCALL  0x08E2			; load registers 24-27, A=0
0x05C4 FC         MOV R4, A 
0x05C5 12 07 BF   LCALL  0x07BF			; check various registers returns with R7 = 1,2 or 3
0x05C8 BF 01 06   CJNE R7,  #0x01, 0x05D1
0x05CB E5 19      MOV A,  X19h
0x05CD 64 01      XRL A,  #0x01
0x05CF 60 03      JZ  0x05D4
;
; Jump Target - Callers: 05C8 
0x05D1 7F 00      MOV R7,  #0x00
0x05D3 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 05CF 
0x05D4 12 00 16   LCALL  0x0016             ; send #79 out UART
0x05D7 7A 00      MOV R2,  #0x00
0x05D9 79 1A      MOV R1,  #0x1A
0x05DB 12 08 C8   LCALL  0x08C8             ; 
0x05DE F5 29      MOV  X29h, A
0x05E0 7D 02      MOV R5,  #0x02
0x05E2 12 02 F3   LCALL  0x02F3			;
0x05E5 EF         MOV A, R7 
0x05E6 64 01      XRL A,  #0x01
0x05E8 60 03      JZ  0x05ED
0x05EA 7F 00      MOV R7,  #0x00
0x05EC 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 05E8 
0x05ED 12 00 16   LCALL  0x0016			; send #79 out uart
0x05F0 AB 1A      MOV R3,  X1Ah
0x05F2 AA 1B      MOV R2,  X1Bh
0x05F4 A9 1C      MOV R1,  X1Ch
0x05F6 12 00 8E   LCALL  0x008E		; routine to read some data from somewhere
0x05F9 64 01      XRL A,  #0x01		; cpl acc.0
0x05FB AB 13      MOV R3,  X13h
0x05FD AA 14      MOV R2,  X14h
0x05FF A9 15      MOV R1,  X15h
0x0601 12 00 D4   LCALL  0x00D4		; routine to write to flash or xram or ram
0x0604 AB 1A      MOV R3,  X1Ah
0x0606 AA 1B      MOV R2,  X1Bh
0x0608 A9 1C      MOV R1,  X1Ch
0x060A 90 00 01   MOV DPTR,  #0x0001
0x060D 12 00 A7   LCALL  0x00A7		; routine to read
0x0610 64 01      XRL A,  #0x01		; cpl acc.0
0x0612 AB 16      MOV R3,  X16h
0x0614 AA 17      MOV R2,  X17h
0x0616 A9 18      MOV R1,  X18h
0x0618 12 00 D4   LCALL  0x00D4		; routine to write to flash or xram or ram
0x061B 7F 01      MOV R7,  #0x01		; result flag R7 = 1 and return
0x061D 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;			Branch of R7 evaluation/reply routine
;				07A3
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 07A3 
0x061E 7B 00      MOV R3,  #0x00
0x0620 7A 00      MOV R2,  #0x00
0x0622 79 0A      MOV R1,  #0x0A
0x0624 12 06 79   LCALL  0x0679		; 
0x0627 EF         MOV A, R7 
0x0628 60 4B      JZ  0x0675
0x062A 12 00 16   LCALL  0x0016			; replies with #79 out uart
0x062D 7A 00      MOV R2,  #0x00
0x062F 79 0C      MOV R1,  #0x0C
0x0631 12 08 E2   LCALL  0x08E2		; 0C00 = secondary loop vector
0x0634 FC         MOV R4, A 
0x0635 12 07 BF   LCALL  0x07BF
0x0638 EF         MOV A, R7 
0x0639 64 01      XRL A,  #0x01
0x063B 60 14      JZ  0x0651
0x063D 7E 00      MOV R6,  #0x00
0x063F E5 0B      MOV A,  X0Bh
0x0641 25 0C      ADD A,  X0Ch
0x0643 FF         MOV R7, A 
0x0644 EE         MOV A, R6 
0x0645 35 0A      ADDC A,  X0Ah
0x0647 FE         MOV R6, A 
0x0648 D3         SETB C 
0x0649 EF         MOV A, R7 
0x064A 94 FF      SUBB A,  #0xFF
0x064C EE         MOV A, R6 
0x064D 94 1D      SUBB A,  #0x1D		; 1DFF pointer?
0x064F 40 24      JC  0x0675
;
; Jump Target - Callers: 063B 
0x0651 12 00 16   LCALL  0x0016			; send #79 out uart
0x0654 E4         CLR A 
0x0655 F5 0D      MOV  X0Dh, A
;
; loop Target - Callers: 0673 
0x0657 E5 0D      MOV A,  X0Dh
0x0659 C3         CLR C 
0x065A 95 0C      SUBB A,  X0Ch
0x065C 50 1A      JNC  0x0678		; EXIT condition
0x065E 7E 00      MOV R6,  #0x00
0x0660 E5 0B      MOV A,  X0Bh
0x0662 25 0D      ADD A,  X0Dh
0x0664 FF         MOV R7, A 
0x0665 EE         MOV A, R6 
0x0666 35 0A      ADDC A,  X0Ah
0x0668 FE         MOV R6, A 
0x0669 12 0B 78   LCALL  0x0B78		; get FLASH at dptr r6r7, return in R7
0x066C 8F 0E      MOV  X0Eh, R7
0x066E 12 00 46   LCALL  0x0046		; send R7 out UART
0x0671 05 0D      INC  X0Dh
0x0673 80 E2      SJMP  0x0657		; repeats loop sending data until
;
; Jump Target - Callers: 0628 064F 
0x0675 12 00 1E   LCALL  0x001E		; at completion, send #1F out UART
;
; EXIT Target - Callers: 065C 
0x0678 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				routine to write and read some data for 
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 01D2 0624 
0x0679 8B 13      MOV  X13h, R3
0x067B 8A 14      MOV  X14h, R2
0x067D 89 15      MOV  X15h, R1
0x067F 7B 00      MOV R3,  #0x00
0x0681 7A 00      MOV R2,  #0x00
0x0683 79 16      MOV R1,  #0x16
0x0685 12 08 CA   LCALL  0x08CA		;
0x0688 F5 29      MOV  X29h, A
0x068A 7D 02      MOV R5,  #0x02
0x068C 12 02 F3   LCALL  0x02F3		;
0x068F EF         MOV A, R7 
0x0690 64 01      XRL A,  #0x01
0x0692 60 03      JZ  0x0697
0x0694 7F 00      MOV R7,  #0x00
0x0696 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0692 
0x0697 AB 16      MOV R3,  X16h
0x0699 AA 17      MOV R2,  X17h
0x069B A9 18      MOV R1,  X18h
0x069D 90 00 01   MOV DPTR,  #0x0001
0x06A0 12 00 A7   LCALL  0x00A7		; READ with R1R2 offsets to dptr
0x06A3 FD         MOV R5, A 
0x06A4 7C 00      MOV R4,  #0x00
0x06A6 12 00 8E   LCALL  0x008E		; READ using R1R2 pointers
0x06A9 FE         MOV R6, A 
0x06AA E4         CLR A 
0x06AB 2D         ADD A, R5 
0x06AC FF         MOV R7, A 
0x06AD EC         MOV A, R4 
0x06AE 3E         ADDC A, R6 
0x06AF AB 13      MOV R3,  X13h
0x06B1 AA 14      MOV R2,  X14h
0x06B3 A9 15      MOV R1,  X15h
0x06B5 8F F0      MOV  B, R7
0x06B7 12 01 11   LCALL  0x0111		; routine to write A and B to flash or Ram or XRam
0x06BA AB 13      MOV R3,  X13h
0x06BC AA 14      MOV R2,  X14h
0x06BE A9 15      MOV R1,  X15h
0x06C0 12 00 E6   LCALL  0x00E6		; routine to read A and B from flash or Ram or XRam
0x06C3 D3         SETB C 
0x06C4 94 FF      SUBB A,  #0xFF
0x06C6 E5 F0      MOV A,  B
0x06C8 94 1D      SUBB A,  #0x1D		; 1DFF pointer ?
0x06CA 40 03      JC  0x06CF
0x06CC 7F 00      MOV R7,  #0x00
0x06CE 22         RET
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
; Jump Target - Callers: 06CA 
0x06CF 7F 01      MOV R7,  #0x01
0x06D1 22         RET
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Read Serial Port 054C, 0A16
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 054C 0A16 	; load registers, check for RX, 
0x06D2 8B 34      MOV  X34h, R3
0x06D4 8A 35      MOV  X35h, R2
0x06D6 89 36      MOV  X36h, R1
0x06D8 8F 3A      MOV  X3Ah, R7		; push gp registers
0x06DA 8E 39      MOV  X39h, R6
0x06DC 8D 38      MOV  X38h, R5
0x06DE 8C 37      MOV  X37h, R4
;
; loop - Callers: 06F2 0705 
0x06E0 20 98 27   JB  SCON.0, 0x070A	; loop for UART rx for R7 =0
0x06E3 12 09 24   LCALL  0x0924			; []
0x06E6 AF 3A      MOV R7,  X3Ah
0x06E8 AE 39      MOV R6,  X39h		; pop  hi gp registers
0x06EA AD 38      MOV R5,  X38h
0x06EC AC 37      MOV R4,  X37h
0x06EE 12 0B 52   LCALL  0x0B52			; []
0x06F1 EF         MOV A, R7 
0x06F2 60 EC      JZ  0x06E0		; loop if R7 =0
0x06F4 E4         CLR A 
0x06F5 FF         MOV R7, A 
0x06F6 FE         MOV R6, A 		; clear the hi gp
0x06F7 FD         MOV R5, A 
0x06F8 FC         MOV R4, A 
0x06F9 AB 3A      MOV R3,  X3Ah
0x06FB AA 39      MOV R2,  X39h		; pop previous hi gp  into the lo gp
0x06FD A9 38      MOV R1,  X38h
0x06FF A8 37      MOV R0,  X37h
0x0701 D3         SETB C 
0x0702 12 01 30   LCALL  0x0130			; []
;
0x0705 40 D9      JC  0x06E0		; loop if C = 1 also
0x0707 7F 02      MOV R7,  #0x02		; exit with R7 = 2 if C = 0
0x0709 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; branch  - jump: 06E0 			; reads UART and stores a byte
0x070A 85 99 66   MOV  X66h, SBUF
0x070D C2 98      CLR  SCON.0
0x070F AB 34      MOV R3,  X34h		; pop the gp registers
0x0711 AA 35      MOV R2,  X35h
0x0713 A9 36      MOV R1,  X36h
0x0715 E5 66      MOV A,  X66h
0x0717 12 00 D4   LCALL  0x00D4		;routine to write the uart data to flash or Ram or XRam
0x071A E5 68      MOV A,  X68h
0x071C 60 05      JZ  0x0723		; check [] flag 68
0x071E AF 66      MOV R7,  X66h
0x0720 12 0A E9   LCALL  0x0AE9		; send the byte back out the daisy chain

; Jump Target - Callers: 071C 
0x0723 7F 01      MOV R7,  #0x01		; load results flag R7 = 1 and return
0x0725 22         RET
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				077B for R7 = #21 branch
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 077B 
0x0726 7F 00      MOV R7,  #0x00
0x0728 7E 1A      MOV R6,  #0x1A
0x072A 12 0B 78   LCALL  0x0B78   ; Look up value at R6,R7 =0x1A00 in FLASH (it's 3)
0x072D EF         MOV A, R7       ; Transfer that value to Accum
0x072E F4         CPL A           ; NOT 3 = 1111 1100 = 0xFC
0x072F 60 42      JZ  0x0773      ; yet again a branch that cannot happen. 0x1A00
0x0731 E4         CLR A           ; zero out accum
0x0732 FB         MOV R3, A       ; zero out R3 and R2 as well.
0x0733 FA         MOV R2, A 
0x0734 7D FD      MOV R5,  #0xFD  ; more register setting for some reason.
0x0736 7C 1B      MOV R4,  #0x1B  
0x0738 FF         MOV R7, A 
0x0739 7E 0C      MOV R6,  #0x0C
0x073B 12 04 A8   LCALL  0x04A8   	; XXX
0x073E 8E 0A      MOV  X0Ah, R6
0x0740 8F 0B      MOV  X0Bh, R7
0x0742 7F FE      MOV R7,  #0xFE
0x0744 7E 1B      MOV R6,  #0x1B
0x0746 12 0B 78   LCALL  0x0B78     	; 1BFE = located at top of 14th page (=#92)
0x0749 EF         MOV A, R7 
0x074A 7F 00      MOV R7,  #0x00
0x074C FE         MOV R6, A 
0x074D C0 06      PUSH  R6
0x074F C0 07      PUSH  R7
0x0751 7F FF      MOV R7,  #0xFF
0x0753 7E 1B      MOV R6,  #0x1B
0x0755 12 0B 78   LCALL  0x0B78     	; 1BFF = last byte of 14th page (= #18)
0x0758 EF         MOV A, R7 
0x0759 FD         MOV R5, A 
0x075A D0 E0      POP  ACC
0x075C 2D         ADD A, R5 
0x075D FF         MOV R7, A 
0x075E D0 E0      POP  ACC
0x0760 34 00      ADDC A,  #0x00
0x0762 FE         MOV R6, A 
0x0763 E5 0B      MOV A,  X0Bh
0x0765 B5 07 0B   CJNE A,  R7, 0x0773
0x0768 E5 0A      MOV A,  X0Ah
0x076A B5 06 06   CJNE A,  R6, 0x0773
0x076D 12 0B D7   LCALL  0x0BD7		;[]
0x0770 12 0C 00   LCALL  0x0C00		;[]
;
; Jump Target - Callers: 072F 0765 076A 
0x0773 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				routine to check R7 and send a message out UART  09C8, 0BD0
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 09C8 0BD0 
0x0774 8F 09      MOV  X09h, R7
0x0776 E5 09      MOV A,  X09h
0x0778 B4 21 03   CJNE A,  #0x21, 0x077E		; does it = #21 (33)
;
0x077B 02 07 26   LJMP  0x0726		; 	
;
; Jump Target - Callers: 0778           ; branch for != 21
;
0x077E 12 00 16   LCALL  0x0016			; first send #79 out the UART
0x0781 E5 09      MOV A,  X09h		; then evaluate the contents of R7 (indicates branch to take)
0x0783 24 E6      ADD A,  #0xE6		
0x0785 60 25      JZ  0x07AC		if R7 + #E6 (-#19) = 0, then send #01
0x0787 24 EF      ADD A,  #0xEF
0x0789 60 24      JZ  0x07AF		if prev result + #EF= 0, then send #06
0x078B 24 FA      ADD A,  #0xFA
0x078D 60 1A      JZ  0x07A9		if p.r.  + #FA = 0, then 
0x078F 24 F5      ADD A,  #0xF5
0x0791 60 1F      JZ  0x07B2
0x0793 24 F9      ADD A,  #0xF9
0x0795 60 0F      JZ  0x07A6
0x0797 24 F6      ADD A,  #0xF6
0x0799 60 1A      JZ  0x07B5
0x079B 24 EF      ADD A,  #0xEF
0x079D 60 19      JZ  0x07B8
0x079F 24 4D      ADD A,  #0x4D
0x07A1 70 18      JNZ  0x07BB
0x07A3 02 06 1E   LJMP  0x061E		;
;
;
; Jump Target - Callers: 0795           ;branches
;
0x07A6 02 02 5C   LJMP  0x025C		;

; Jump Target - Callers: 078D 
0x07A9 02 01 B1   LJMP  0x01B1		; 

; Jump Target - Callers: 0785 
0x07AC 02 00 06   LJMP  0x0006		; sends #01 out UART

; Jump Target - Callers: 0789 
0x07AF 02 00 0E   LJMP  0x000E		; sends #06 out UART

; Jump Target - Callers: 0791 
0x07B2 02 0B B0   LJMP  0x0BB0		; send dprt 1A00 = #03 out UART

; Jump Target - Callers: 0799 		; ? send Second Loop or RESET Vector
0x07B5 02 0B BA   LJMP  0x0BBA		; calc dptr hilo address to send out UART

; Jump Target - Callers: 079D 		; ? send External address or Second loop vector
0x07B8 02 0B 84   LJMP  0x0B84		; calc dptr hilo to send out UART

; Jump Target - Callers: 07A1 
0x07BB 12 00 1E   LCALL  0x001E		; at completion of routine, sends #1F out UART
0x07BE 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;					; routine to check various registers returns with R7 = 1,2 or 3
; Jump Target - Callers: 081A 09B5 05C5 0635 	; load values into registers
0x07BF 8B 1D      MOV  X1Dh, R3
0x07C1 8A 1E      MOV  X1Eh, R2
0x07C3 89 1F      MOV  X1Fh, R1
0x07C5 7B 00      MOV R3,  #0x00
0x07C7 7A 00      MOV R2,  #0x00
0x07C9 79 3B      MOV R1,  #0x3B
0x07CB 12 09 F7   LCALL  0x09F7		; clear 5D-60 counter, Read UART, store and send back out 
0x07CE EF         MOV A, R7 
0x07CF 64 01      XRL A,  #0x01			; check result
0x07D1 60 03      JZ  0x07D6
0x07D3 7F 02      MOV R7,  #0x02			; load R7 = 2 and return
0x07D5 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 07D1 		; branch if previous batch failed	
0x07D6 7B 00      MOV R3,  #0x00
0x07D8 7A 00      MOV R2,  #0x00
0x07DA 79 28      MOV R1,  #0x28		; try a different set of values/registers
0x07DC AF 27      MOV R7,  X27h
0x07DE AE 26      MOV R6,  X26h
0x07E0 AD 25      MOV R5,  X25h
0x07E2 AC 24      MOV R4,  X24h
0x07E4 12 09 F7   LCALL  0x09F7		; clear 5D-60 counter, Read UART, store and send back out
0x07E7 EF         MOV A, R7 
0x07E8 64 01      XRL A,  #0x01			; check result
0x07EA 60 03      JZ  0x07EF
0x07EC 7F 02      MOV R7,  #0x02			; load R7 = 2 and return
0x07EE 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 07EA 		; branch if both attempts failed
0x07EF E5 28      MOV A,  X28h
0x07F1 F4         CPL A 
0x07F2 65 3B      XRL A,  X3Bh
0x07F4 60 06      JZ  0x07FC		; check result
0x07F6 12 00 1E   LCALL  0x001E
0x07F9 7F 03      MOV R7,  #0x03			; load R7 = 3 and return
0x07FB 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 07F4 		; try another batch of registers
0x07FC AB 1D      MOV R3,  X1Dh
0x07FE AA 1E      MOV R2,  X1Eh
0x0800 A9 1F      MOV R1,  X1Fh
0x0802 E5 3B      MOV A,  X3Bh
0x0804 12 00 D4   LCALL  0x00D4		; routine to write to flash or Ram or XRam
0x0807 7F 01      MOV R7,  #0x01			 ; load R7 =1 and return
0x0809 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers:                ; Third jump target in main loop jump table
0x080A 7F 01      MOV R7,  #0x01
0x080C 12 00 4E   LCALL  0x004E
0x080F 7A 00      MOV R2,  #0x00
0x0811 79 08      MOV R1,  #0x08
0x0813 12 0B 2A   LCALL  0x0B2A
0x0816 FF         MOV R7, A 
0x0817 FE         MOV R6, A 
0x0818 FD         MOV R5, A 
0x0819 FC         MOV R4, A 
0x081A 12 07 BF   LCALL  0x07BF
0x081D EF         MOV A, R7 
0x081E 64 01      XRL A,  #0x01
0x0820 60 04      JZ  0x0826
0x0822 75 69 05   MOV  X69h, #0x05      ; set selector to 05
0x0825 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0820           ;branch in main third [acc = R7 = 0]
0x0826 D2 93      SETB  P1.3            ; turn on LED
0x0828 E5 08      MOV A,  X08h
0x082A D3         SETB C 
0x082B 94 10      SUBB A,  #0x10
0x082D 40 06      JC  0x0835
0x082F 75 69 05   MOV  X69h, #0x05      ; set selector to 05
0x0832 C2 93      CLR  P1.3             ; turn off LED
0x0834 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 082D           ; branch in main third C=1
0x0835 12 00 3E   LCALL  0x003E
0x0838 EF         MOV A, R7 
0x0839 B5 08 08   CJNE A,  X08h, 0x0844
0x083C 12 00 16   LCALL  0x0016         ; loads R7 = #79 and goes to [   ]
0x083F 75 69 03   MOV  X69h, #0x03      ; set selector to 03
0x0842 80 03      SJMP  0x0847
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0839 
0x0844 75 69 04   MOV  X69h, #0x04      ; set selector to 04
;
; Jump Target - Callers: 0842 
0x0847 E4         CLR A 
0x0848 FF         MOV R7, A 
0x0849 12 00 4E   LCALL  0x004E
0x084C 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;				FLASH LOCK AND KEY
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 098A           ; Evaluate Flash Lock and Key, and enable flash W/E
0x084D 75 FF A0   MOV  VDDMON, #0xA0
0x0850 E5 B7      MOV A,  FLKEY
0x0852 64 02      XRL A,  #0x02
0x0854 60 10      JZ  0x0866		; check if key is unlocked
0x0856 12 00 8E   LCALL  0x008E
0x0859 F5 B7      MOV  FLKEY, A		; if not go read data somewhere to load key
0x085B AB 2D      MOV R3,  X2Dh
0x085D AA 2E      MOV R2,  X2Eh
0x085F A9 2F      MOV R1,  X2Fh
0x0861 12 00 8E   LCALL  0x008E		; go read data again to load key
0x0864 F5 B7      MOV  FLKEY, A
;
; Jump Target - Callers: 0854 		; check key again
0x0866 E5 B7      MOV A,  FLKEY
0x0868 64 02      XRL A,  #0x02
0x086A 60 03      JZ  0x086F		
0x086C 7F 00      MOV R7,  #0x00		; if still locked the set R7 flag =0
0x086E 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 086A 		; check flag ?(X30) = 2, then enable Flash W and E
0x086F E5 30      MOV A,  X30h
0x0871 B4 02 05   CJNE A,  #0x02, 0x0879
0x0874 75 8F 03   MOV  PSCTL, #0x03
0x0877 80 0F      SJMP  0x0888
;
; Jump Target - Callers: 0871 		; but if flag (30) =1, then enable flash W
0x0879 E5 30      MOV A,  X30h
0x087B B4 01 05   CJNE A,  #0x01, 0x0883
0x087E 75 8F 01   MOV  PSCTL, #0x01
0x0881 80 05      SJMP  0x0888
;
; Jump Target - Callers: 087B 		; if the flag (30) was neither, then disable Flash W or E
0x0883 E4         CLR A 
0x0884 F5 8F      MOV  PSCTL, A
0x0886 FF         MOV R7, A 		; clear the R7 flag and exit
0x0887 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0881 0877 	; in both enable cases, set R7 flag and exit
0x0888 7F 01      MOV R7,  #0x01
0x088A 22         RET                           ; exit Flashroutine
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 02CE 
0x088B E4         CLR A 
0x088C FF         MOV R7, A 
;
; Jump Target - Callers: 0899                   ; loop on R7 counter
0x088D EF         MOV A, R7 
0x088E 90 0B E5   MOV DPTR,  #0x0BE5            ; 6 value state code table 00 01...05
0x0891 93         MOVC A, @A+DPTR 
0x0892 B5 18 03   CJNE A,  X18h, 0x0898         ; compare register 18 ?= state code value
0x0895 7F 03      MOV R7,  #0x03                ; if so then load R7 = #03 and return
0x0897 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0892 
0x0898 0F         INC R7                        ; branch on register 18
0x0899 BF 07 F1   CJNE R7,  #0x07, 0x088D       ; repeat loop up to 6 times
0x089C E5 18      MOV A,  X18h
0x089E B4 0E 03   CJNE A,  #0x0E, 0x08A4        ; compare reg 18 ?= #0E
0x08A1 7F 03      MOV R7,  #0x03                ; if so then load R7 = #03 and return            
0x08A3 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 089E 
0x08A4 E5 18      MOV A,  X18h                  ; branch on reg 18
0x08A6 25 E0      ADD A,  ACC
0x08A8 85 15 23   MOV  X23h, X15h
0x08AB 85 16 24   MOV  X24h, X16h
0x08AE 85 17 25   MOV  X25h, X17h
0x08B1 F5 26      MOV  X26h, A
0x08B3 75 27 00   MOV  X27h, #0x00
0x08B6 E4         CLR A 
0x08B7 F5 28      MOV  X28h, A
0x08B9 75 29 02   MOV  X29h, #0x02
0x08BC 12 09 7E   LCALL  0x097E
0x08BF EF         MOV A, R7 
0x08C0 70 03      JNZ  0x08C5
0x08C2 7F 03      MOV R7,  #0x03            ; if R7 =0 then load R7 = #03 and return
0x08C4 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 08C0 
0x08C5 7F 01      MOV R7,  #0x01            ; branch if R7 !=0 then load R7 = #01 and return
0x08C7 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 05DB 0292          ; 
0x08C8 7B 00      MOV R3,  #0x00
;
; Jump Target - Callers: 0685 
0x08CA 75 24 40   MOV  X24h, #0x40
0x08CD 75 23 28   MOV  X23h, #0x28
0x08D0 75 22 BA   MOV  X22h, #0xBA
0x08D3 75 21 00   MOV  X21h, #0x00
0x08D6 E4         CLR A 
;
; Jump Target - Callers: 0201 
0x08D7 75 28 F6   MOV  X28h, #0xF6
0x08DA 75 27 0B   MOV  X27h, #0x0B
0x08DD F5 26      MOV  X26h, A
0x08DF F5 25      MOV  X25h, A
0x08E1 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;					Load values into registers and return
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 05C1 0631 		; load values into registers
0x08E2 7B 00      MOV R3,  #0x00
0x08E4 E4         CLR A 
0x08E5 75 27 F6   MOV  X27h, #0xF6
0x08E8 75 26 0B   MOV  X26h, #0x0B
0x08EB F5 25      MOV  X25h, A
0x08ED F5 24      MOV  X24h, A
;
; Jump Target - Callers: 027A 
0x08EF 7F 40      MOV R7,  #0x40
0x08F1 7E 28      MOV R6,  #0x28
0x08F3 7D BA      MOV R5,  #0xBA
0x08F5 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0B3E 
0x08F6 8E 08      MOV  X08h, R6
0x08F8 8F 09      MOV  X09h, R7
0x08FA E4         CLR A 
0x08FB F5 0A      MOV  X0Ah, A
0x08FD 80 0A      SJMP  0x0909
;
; Jump Target - Callers: 090C 091C 0921     ; UART Processing
0x08FF E5 0A      MOV A,  X0Ah              ; loop
0x0901 70 20      JNZ  0x0923               ; exit if reg 0A !=0
0x0903 12 0A C4   LCALL  0x0AC4         ; go check if RX has data and send it back out TX
0x0906 EF         MOV A, R7 
0x0907 60 05      JZ  0x090E
;
; Jump Target - Callers: 08FD 
0x0909 12 0B C4   LCALL  0x0BC4         ; clear registers 5D-60 [ counter values for WD timer?] see 092B
0x090C 80 F1      SJMP  0x08FF           ; repeat loop
;
; Jump Target - Callers: 0907 
0x090E 12 09 24   LCALL  0x0924
0x0911 AE 08      MOV R6,  X08h
0x0913 AF 09      MOV R7,  X09h
0x0915 E4         CLR A 
0x0916 FC         MOV R4, A 
0x0917 FD         MOV R5, A 
0x0918 12 0B 52   LCALL  0x0B52
0x091B EF         MOV A, R7 
0x091C 60 E1      JZ  0x08FF            ; repeat loop
0x091E 75 0A 01   MOV  X0Ah, #0x01
0x0921 80 DC      SJMP  0x08FF          ; repeat loop
;
; Jump Target - Callers: 0901 
0x0923 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 06E3 090E          
0x0924 E5 61      MOV A,  X61h              ; grab value from RAM 0x61
0x0926 60 03      JZ  0x092B                ; if it was zero then jump over next line
0x0928 75 EC FF   MOV  PCACPH2, #0xFF       ; Otherwise, set CPH2 to 0xFF (reset watchdog timer)
;
; Jump Target - Callers: 0926 
0x092B 30 CF 23   JNB  TMP2CN.7, 0x0951     ; If timer 2 overflow flag not set then jump to RET
0x092E 74 FF      MOV A,  #0xFF             ; Set A to 0xFF
0x0930 FF         MOV R7, A                 ; Set R4, R5, R6, R7 all to 0xFF
0x0931 FE         MOV R6, A 
0x0932 FD         MOV R5, A 
0x0933 FC         MOV R4, A 
0x0934 C3         CLR C                     ; Clear carry flag
0x0935 12 0B 9A   LCALL  0x0B9A             ; Subtractions and ORs on all registers (regs R0 - R3 set within this routine)
0x0938 50 15      JNC  0x094F               ; If those operations never carried then go to 0x94F (skip the 32 bit increment)
0x093A E5 60      MOV A,  X60h              ; start a cascading operation to increment a 32 bit counter in RAM 0x5D - 0x60
0x093C 24 01      ADD A,  #0x01
0x093E F5 60      MOV  X60h, A
0x0940 E4         CLR A 
0x0941 35 5F      ADDC A,  X5Fh             ; just for reference, this is the only place that this counter is incremented
0x0943 F5 5F      MOV  X5Fh, A              ; The only other place it is touched is to reset it to zero.
0x0945 E4         CLR A 
0x0946 35 5E      ADDC A,  X5Eh
0x0948 F5 5E      MOV  X5Eh, A
0x094A E4         CLR A 
0x094B 35 5D      ADDC A,  X5Dh
0x094D F5 5D      MOV  X5Dh, A              ; end of cascading operation for 32 bit increment.
;
; Jump Target - Callers: 0938 
0x094F C2 CF      CLR  TMP2CN.7             ; clear timer 2 overflow flag
;
; Jump Target - Callers: 092B 
0x0951 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0593 0250 
0x0952 8F 13      MOV  X13h, R7
0x0954 E4         CLR A 
0x0955 F5 18      MOV  X18h, A
;
; Jump Target - Callers: 0979 
0x0957 E5 18      MOV A,  X18h
0x0959 C3         CLR C 
0x095A 95 13      SUBB A,  X13h
0x095C 50 1D      JNC  0x097B
0x095E 7B 00      MOV R3,  #0x00
0x0960 7A 00      MOV R2,  #0x00
0x0962 79 19      MOV R1,  #0x19
0x0964 AF 17      MOV R7,  X17h
0x0966 AE 16      MOV R6,  X16h
0x0968 AD 15      MOV R5,  X15h
0x096A AC 14      MOV R4,  X14h
0x096C 12 09 F7   LCALL  0x09F7		; clear 5D-60 counter, Read UART, store and send back out
0x096F EF         MOV A, R7 
0x0970 64 01      XRL A,  #0x01
0x0972 60 03      JZ  0x0977
0x0974 7F 02      MOV R7,  #0x02
0x0976 22         RET
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
;
; Jump Target - Callers: 0972 
0x0977 05 18      INC  X18h
0x0979 80 DC      SJMP  0x0957
;
; Jump Target - Callers: 095C 
0x097B 7F 01      MOV R7,  #0x01
0x097D 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;					Routine to write data to Flash Memory
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 03F5 08BC 	checking flash lock and key, and enable flash Write/Erase controls
0x097E 85 23 2D   MOV  X2Dh, X23h
0x0981 85 24 2E   MOV  X2Eh, X24h		; registers with R1R2 pointer locations, R3 state and W/E flag
0x0984 85 25 2F   MOV  X2Fh, X25h
0x0987 85 29 30   MOV  X30h, X29h
0x098A 12 08 4D   LCALL  0x084D		; go see if flash key is unlocked and enable W/E controls
0x098D EF         MOV A, R7 		; check the answer
0x098E 70 02      JNZ  0x0992		; if set skip over
0x0990 FF         MOV R7, A 		; if clear then key was locked or W/E is disabled
0x0991 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; branch - Callers: 098E 		; flash key was unlocked and some W/E has been enabled 
0x0992 85 26 62   MOV  X62h, X26h
0x0995 85 27 63   MOV  X63h, X27h
0x0998 85 63 82   MOV  DPL, X63h		; so load the dptr (Flash address) from RAM 
0x099B 85 62 83   MOV  DPH, X62h
0x099E E5 28      MOV A,  X28h		; get the desired byte 
0x09A0 F0         MOVX @DPTR, A 		; and write it to Flash
0x09A1 12 0B DE   LCALL  0x0BDE		; allow Vdd resets but disable flash W/E   
0x09A4 7F 01      MOV R7,  #0x01		; set R7 flag and exit
0x09A6 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				4th JUMP TARGET IN MAIN LOOP
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers:                
0x09A7 7A 00      MOV R2,  #0x00
0x09A9 79 08      MOV R1,  #0x08
0x09AB 12 0B 2A   LCALL  0x0B2A		; loads R3 and other registers
0x09AE 7F 40      MOV R7,  #0x40
0x09B0 7E 28      MOV R6,  #0x28
0x09B2 7D BA      MOV R5,  #0xBA
0x09B4 FC         MOV R4, A 
0x09B5 12 07 BF   LCALL  0x07BF		; 
0x09B8 C2 93      CLR  P1.3             ; turn off LED
0x09BA EF         MOV A, R7 
0x09BB 64 01      XRL A,  #0x01
0x09BD 60 07      JZ  0x09C6
0x09BF 12 00 1E   LCALL  0x001E
0x09C2 75 69 04   MOV  X69h, #0x04      ; set selector to 04
0x09C5 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 09BD 
0x09C6 AF 08      MOV R7,  X08h
0x09C8 12 07 74   LCALL  0x0774
0x09CB 75 69 02   MOV  X69h, #0x02      ; set selector to 02
0x09CE 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0A60 
0x09CF 7A 00      MOV R2,  #0x00
0x09D1 79 08      MOV R1,  #0x08
0x09D3 12 0B 8F   LCALL  0x0B8F
0x09D6 12 09 F7   LCALL  0x09F7		; clear 5D-60 counter, Read UART, store and send back out
0x09D9 EF         MOV A, R7 
0x09DA 64 01      XRL A,  #0x01
0x09DC 60 08      JZ  0x09E6
0x09DE 7F 01      MOV R7,  #0x01
0x09E0 12 00 56   LCALL  0x0056
0x09E3 7F 02      MOV R7,  #0x02
0x09E5 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 09DC 
0x09E6 E5 08      MOV A,  X08h
0x09E8 04         INC A 
0x09E9 F5 5C      MOV  X5Ch, A
0x09EB FF         MOV R7, A 
0x09EC 12 0A E9   LCALL  0x0AE9
0x09EF 7F 01      MOV R7,  #0x01
0x09F1 12 00 56   LCALL  0x0056
0x09F4 7F 01      MOV R7,  #0x01
0x09F6 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;			Push gp registers, clear 32-bit counter, pop gp, Read/Send UART
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 096C 09D6 07CB 07E4 0382 01E9 027F 
0x09F7 8B 2D      MOV  X2Dh, R3
0x09F9 8A 2E      MOV  X2Eh, R2
0x09FB 89 2F      MOV  X2Fh, R1		; push registers to store values
0x09FD 8F 33      MOV  X33h, R7
0x09FF 8E 32      MOV  X32h, R6
0x0A01 8D 31      MOV  X31h, R5
0x0A03 8C 30      MOV  X30h, R4
0x0A05 12 0B C4   LCALL  0x0BC4             ; clear the 32-bit counter  5D-60 [watchdog?]
0x0A08 AB 2D      MOV R3,  X2Dh
0x0A0A AA 2E      MOV R2,  X2Eh
0x0A0C A9 2F      MOV R1,  X2Fh
0x0A0E AF 33      MOV R7,  X33h		; pop values back to gp registers
0x0A10 AE 32      MOV R6,  X32h
0x0A12 AD 31      MOV R5,  X31h
0x0A14 AC 30      MOV R4,  X30h
0x0A16 12 06 D2   LCALL  0x06D2             ; Read UART byte, store in X66, send it back out
0x0A19 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				1st Jump Target in MAIN Loop
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers:             First entry in main loop jump table 
0x0A1A 7F 01      MOV R7,  #0x01    ;R7 = 1
0x0A1C 12 00 4E   LCALL  0x004E     ; call does nothing but set RAM 0x61 to R7 (so 1 in this case)
0x0A1F C2 93      CLR  P1.3         ; Turn off LED
0x0A21 D2 93      SETB  P1.3        ; Turn it on... Yeah, that was fun
0x0A23 12 05 32   LCALL  0x0532     ; Initializes some RAM locations (x9, xA, xB, x69)
0x0A26 EF         MOV A, R7         ; Above call left R7 = 1
0x0A27 64 06      XRL A,  #0x06     ; 1 ^ 6 = 7
0x0A29 60 06      JZ  0x0A31        ; Ah... this could never be zero?! I see no way this could ever branch...
0x0A2B 75 69 05   MOV  X69h, #0x05  ; Set main loop branch selector byte to 5
0x0A2E C2 93      CLR  P1.3         ; Turn LED off
0x0A30 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0A29 
0x0A31 C2 93      CLR  P1.3             ; turn off LED
0x0A33 75 69 01   MOV  X69h, #0x01      ; set selector to 01
0x0A36 E4         CLR A 
0x0A37 FF         MOV R7, A 
0x0A38 12 00 4E   LCALL  0x004E
0x0A3B 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				MAIN LOOP
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0B08           ; Fourth/final StartInitHware CALL routine => start of [MAIN]
0x0A3C E4         CLR A 
0x0A3D F5 69      MOV  X69h, A          ; clear selector register x69 = #00
;
; MAINLOOPTarget - Callers: 0A59    ; [MAIN] Basically an infinite loop
;                                   ; This appears to be the main program loop
0x0A3F E5 69      MOV A,  X69h      ; grab value from state selector register x69, 
;					initially 00, later low byte of dptr [00-05]
;
;
;
;
;
;
;
0x0A41 75 F0 03   MOV B, #0x03     
0x0A44 A4         MUL AB            ; Multiply value from x69 since data format is FF hi lo, 3 bytes
0x0A45 24 D7      ADD A,  #0xD7     ; Add 0xD7 to result [D7 + offset]
0x0A47 F5 82      MOV DPL, A        ; DPTR low byte
0x0A49 E4         CLR A 
0x0A4A 34 0A      ADDC A,  #0x0A    
0x0A4C F5 83      MOV DPH, A        ; Set high byte of DPTR to 0A
0x0A4E 74 01      MOV A,  #0x01
0x0A50 93         MOVC A, @A+DPTR   ; Look up 1 + DPTR (skip over the FF) DPTR is at #0AD7 + offset for state = main jump table data
0x0A51 FA         MOV R2, A         ; store in R2  dph
0x0A52 74 02      MOV A,  #0x02     
0x0A54 93         MOVC A, @A+DPTR   ; Look up 2 + DPTR and store in R1 dph
0x0A55 F9         MOV R1, A         
0x0A56 12 01 90   LCALL  0x0190     ; Program Execution jumps to dptr address from R1 R2 
0x0A59 80 E4      SJMP  0x0A3F      ; loop back to top of this routine
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				2ND JUMP TARGET IN MAIN LOOP
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers:            
0x0A5B 7F 01      MOV R7,  #0x01
0x0A5D 12 00 4E   LCALL  0x004E
0x0A60 12 09 CF   LCALL  0x09CF
0x0A63 EF         MOV A, R7 
0x0A64 64 01      XRL A,  #0x01
0x0A66 60 06      JZ  0x0A6E
0x0A68 C2 93      CLR  P1.3             ; turn off LED
0x0A6A 75 69 05   MOV  X69h, #0x05      ; set selector to 05
0x0A6D 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0A66 
0x0A6E 75 69 02   MOV  X69h, #0x02      ; set selector to 02
0x0A71 C2 93      CLR  P1.3             ; turn off LED
0x0A73 E4         CLR A 
0x0A74 FF         MOV R7, A 
0x0A75 12 00 4E   LCALL  0x004E
0x0A78 22         RET
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
;				Second Init LCall routine Timer Setup
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
; LCALL Target - Callers: 0B00          ; Second init LCALL [Timer Setup]
0x0A79 D2 8E      SETB  TCON.6          ;enable timer 1 run control - used for UART
0x0A7B 75 89 20   MOV  TMOD, #0x20      ;Timer Mode 0010 0000 = mode 2 - 8 bit auto reload
0x0A7E 75 8D EC   MOV  TH1, #0xEC       ;Timer 1 high byte = 0xEC
0x0A81 75 8E 18   MOV  CKCON, #0x18     ;CKCON = 0001 1000 = Timer 2 low byte uses system clock, Timer 1 uses system clock
0x0A84 D2 CA      SETB  TMP2CN.2        ;Set TMR2CN bit 2 = Timer 2 is enabled
0x0A86 C2 CB      CLR  TMP2CN.3         ;Clear Timer 2 CN bit 3 = operate in 16 bit mode
0x0A88 75 CA 6F   MOV  TMR2RLL, #0x6F   ;set up timer count registers.
0x0A8B 75 CB FE   MOV  TMR2RLH, #0xFE   ; FE6F = 65135 
0x0A8E 75 CC 6F   MOV  TMP2L, #0x6F     ; If timer runs 24.5MHz that's about 2.65ms timeout... why?
0x0A91 75 CD FE   MOV  TMR2H, #0xFE     ;
0x0A94 22         RET                   ; exit back to 0B03
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;					; 3rd subLcall of first init call
; Jump Target - Callers: 0B12 - init routine called from reset vector - initializes ports
; According to our schematic, P1.3 is connected to the LED, P0.0 is SCLK, P0.1 is MISO, P0.2 is MOSI, P0.3 is CS
; P0.4 is UART TX, P0.5 is UART RX
0x0A95 75 A5 FF   MOV  P1MDOUT, #0xFF   ;Set P1 MDOUT to all be push/pull
0x0A98 75 A4 9D   MOV  P0MDOUT, #0x9D   ;Set P0 MDOUT to 1001 1101 (1 = push/pull 0 = open drain)
0x0A9B 75 80 6A   MOV  P0, #0x6A        ;Set P0 pins to 0110 1010 (0 = low, 1 = high)
0x0A9E 75 D5 FF   MOV  P1SKIP, #0xFF    ;Set P1SKIP to all 1's (Skip all of them with crossbar)
0x0AA1 E4         CLR A 
0x0AA2 F5 90      MOV  P1, A            ;Set all P1 pins to low
0x0AA4 75 D4 F8   MOV  P0SKIP, #0xF8    ;Set P0SKIP to 1111 1000 (skip first 5 pins with crossbar)
0x0AA7 75 E1 03   MOV  XBR0, #0x03      ;Set crossbar 0 to 0000 0011 (Enable SPI and UART on pins)
0x0AAA 75 E2 C0   MOV  XBR1, #0xC0      ;Set crossbar 1 to 1100 0000 (Disable weak pull ups, enable crossbar)
0x0AAD 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				Send calculated DPTR Hi:Lo addresses out the UART		
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0BC1 0B8C 
0x0AAE E4         CLR A 
0x0AAF FB         MOV R3, A 
0x0AB0 FA         MOV R2, A 
0x0AB1 12 04 A8   LCALL  0x04A8		; 16-bit math to calc dptr values 0b78 r6 hi r7 lo
0x0AB4 8E 0A      MOV  X0Ah, R6
0x0AB6 8F 0B      MOV  X0Bh, R7
0x0AB8 EE         MOV A, R6 
0x0AB9 FF         MOV R7, A 
0x0ABA 12 00 46   LCALL  0x0046		; send hi out UART
0x0ABD AF 0B      MOV R7,  X0Bh
0x0ABF E5 0B      MOV A,  X0Bh	? what's the point
0x0AC1 02 00 46   LJMP  0x0046		; send lo out UART
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;					Read UART
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0903 
0x0AC4 30 98 0D   JNB  SCON.0, 0x0AD4
0x0AC7 85 99 66   MOV  X66h, SBUF
0x0ACA C2 98      CLR  SCON.0
0x0ACC AF 66      MOV R7,  X66h
0x0ACE 12 0A E9   LCALL  0x0AE9
0x0AD1 7F 01      MOV R7,  #0x01
0x0AD3 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0AC4 
0x0AD4 7F 00      MOV R7,  #0x00
0x0AD6 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Main Jump Data Table      ; main jump targets. 
;                           ; Selector is carried in register 69, 00 01 02 03 04 05, from data table@ 0BE5
0x0AD7            0xFF      ; The pattern is FF then two bytes hi:lo form a 16 bit jump target address.
0x0AD8            0x0A      ;First target 0x0A1A
0x0AD9            0x1A
0x0ADA            0xFF
0x0ADB            0x0A      ;Second target 0x0A5B
0x0ADC            0x5B 
0x0ADD            0xFF
0x0ADE            0x08      ;Third target 0x080A
0x0ADF            0x0A
0x0AE0            0xFF
0x0AE1            0x09      ;Fourth target 0x09A7
0x0AE2            0xA7
0x0AE3            0xFF
0x0AE4            0x0B      ;Fifth target 0x0B38
0x0AE5            0x38
0x0AE6            0xFF
0x0AE7            0x0B      ;Sixth target 0x0BCE
0x0AE8            0xCE
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;                     		Send R7 data out serial port UART, x67 is flag register
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                            
; Jump Target - Callers: 0720 09EC 0020 0018 0046 0ACE 
0x0AE9 E5 67      MOV A,  X67h
0x0AEB 60 08      JZ  0x0AF5
;
; Jump Target - Callers: 0AED 
0x0AED 30 99 FD   JNB  SCON.1, 0x0AED   ; wait here for transmit complete
0x0AF0 C2 99      CLR  SCON.1
0x0AF2 E4         CLR A 
0x0AF3 F5 67      MOV  X67h, A
;
; Jump Target - Callers: 0AEB 
0x0AF5 75 67 01   MOV  X67h, #0x01
0x0AF8 8F 99      MOV  SBUF, R7         ; send R7 to SBUF
0x0AFA 22         RET                   ; returns from calls or from jumps 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				Start Hardware Init Routines [main]
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; LJump Target - Callers: 0428      ; starting init routines after Bl exit
0x0AFB 12 0B 0C   LCALL  0x0B0C     ; First init call [VDDmon, PCA0, watchdog, P0, P1, Oscillator]
0x0AFE D2 93      SETB  P1.3        ; P1.3 LED indicator for start init
0x0B00 12 0A 79   LCALL  0x0A79     ; Second init call [Setup timers (Timer 2 and Timer 1 for UART)]
0x0B03 12 0B A5   LCALL  0x0BA5     ; Third init call  [Set up UART]
0x0B06 C2 93      CLR  P1.3         ; Turn LED off, init completed
0x0B08 12 0A 3C   LCALL  0x0A3C     ; Fourth init call  [call into the main system loop, interrupts still off initially]
0x0B0B 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				First init call routine set of lcalls [main]
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0AFB       ; First init call routine set of lcalls
0x0B0C 12 0B 45   LCALL  0x0B45     ; 1.  enable voltage monitor and set it as reset source
0x0B0F 12 00 26   LCALL  0x0026     ; 2.  disable all PCA0 functions / make sure watchdog is off
0x0B12 12 0A 95   LCALL  0x0A95     ; 3.  initialize ports P0 and P1
0x0B15 12 00 2E   LCALL  0x002E     ; 4.  Set internal oscillator parameters
0x0B18 02 00 36   LJMP  0x0036      ; 5.  Turn off interrupts globally, then return to starting init 0AFE
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 03E7 040C 
0x0B1B AB 1B      MOV R3,  X1Bh
0x0B1D AA 1C      MOV R2,  X1Ch
0x0B1F A9 1D      MOV R1,  X1Dh
0x0B21 85 1F 82   MOV  DPL, X1Fh
0x0B24 75 83 00   MOV  DPH, #0x00
0x0B27 02 00 A7   LJMP  0x00A7		; go read data from XRAM or flash and ret
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0813 09AB 
0x0B2A 7B 00      MOV R3,  #0x00
0x0B2C E4         CLR A 
0x0B2D 75 27 F6   MOV  X27h, #0xF6
0x0B30 75 26 0B   MOV  X26h, #0x0B
0x0B33 F5 25      MOV  X25h, A
0x0B35 F5 24      MOV  X24h, A
0x0B37 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				Fifth jump target in main loop jump table
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers:                   
0x0B38 C2 93      CLR  P1.3
0x0B3A 7F B6      MOV R7,  #0xB6
0x0B3C 7E B2      MOV R6,  #0xB2
0x0B3E 12 08 F6   LCALL  0x08F6
0x0B41 75 69 02   MOV  X69h, #0x02
0x0B44 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0B0C               ; first lcall of first init call set 
0x0B45 75 FF 80   MOV  VDDMON, #0x80        ;enable VDDMon
0x0B48 E4         CLR A 
0x0B49 FF         MOV R7, A 
;
; Jump Target - Callers: 0B4B               ; wait loop
0x0B4A 0F         INC R7 
0x0B4B BF 14 FC   CJNE R7,  #0x14, 0x0B4A   ; Wait a bit of time after enabling VDDMON
0x0B4E 75 EF 02   MOV  RSTSRC, #0x02        ; Set VDDMON as reset source
0x0B51 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 06EE 0918 
0x0B52 D3         SETB C 
0x0B53 12 0B 9A   LCALL  0x0B9A		;[]
0x0B56 40 04      JC  0x0B5C
0x0B58 7F 01      MOV R7,  #0x01
0x0B5A 80 02      SJMP  0x0B5E
;
; Jump Target - Callers: 0B56 
0x0B5C 7F 00      MOV R7,  #0x00
;
; Jump Target - Callers: 0B5A 
0x0B5E 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				StartInitMem data table [main]
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; "StartInitMem" data table used in start routine
0x0B5F            0x05              ;  from x0463
0x0B60            0x5D (])
0x0B61            0x00
0x0B62            0x00
0x0B63            0x00
0x0B64            0x00
0x0B65            0x00
0x0B66            0x03
0x0B67            0x66 (f)
0x0B68            0x00
0x0B69            0x00
0x0B6A            0x01
0x0B6B            0x00
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
0x0B6C            0x42 (B)          ; from 0B6C
0x0B6D            0x4F (O)
0x0B6E            0x4F (O)
0x0B6F            0x54 (T)
0x0B70            0x6C (l)
0x0B71            0x6F (o)
0x0B72            0x61 (a)
0x0B73            0x64 (d)
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
0x0B74            0x81              ; from 055E
0x0B75            0x8A
0x0B76            0x85
0x0B77            0x88
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				DPTR read at R6R7 and return with value in R7
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0409 0BB4 04C3 04D1 0669 072A 0746 0755 
; Seems to be a look up function that sets the current look up bytes to RAM 0x64:0x65 then sets them into DPTR
; R7 is low byte, R6 is high byte;
; Look up that byte in FLASH and return it in R7
0x0B78 8E 64      MOV  X64h, R6
0x0B7A 8F 65      MOV  X65h, R7		; push gp R6 R7 to ram 64 65
0x0B7C 8F 82      MOV  DPL, R7
0x0B7E 8E 83      MOV  DPH, R6
0x0B80 E4         CLR A 
0x0B81 93         MOVC A, @A+DPTR 
0x0B82 FF         MOV R7, A 		; read byte at dptr into R7 and return 
0x0B83 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				Load gp registers to calc dptr hi:lo and send out UART
;			Send External address  or  Secondary Loop Vector
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 07B8 
0x0B84 7D FD      MOV R5,  #0xFD		looking at 1BFD vs 0C00
0x0B86 7C 1B      MOV R4,  #0x1B
0x0B88 7F 00      MOV R7,  #0x00		top of 14th page  vs  secondary loop
0x0B8A 7E 0C      MOV R6,  #0x0C		; FF (92 18)            02 (0D 2D)
;					start address to point next 2 bytes for LJ
0x0B8C 02 0A AE   LJMP  0x0AAE		; Send calc dptr hi:lo out the UART
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				load gp registers R3-R7
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0549 09D3 
0x0B8F 7B 00      MOV R3,  #0x00
0x0B91 7F 90      MOV R7,  #0x90
0x0B93 7E DC      MOV R6,  #0xDC
0x0B95 7D 01      MOV R5,  #0x01
0x0B97 7C 00      MOV R4,  #0x00
0x0B99 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				POP 32-bit T/C from 5D-60 to gp registers
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0935 0B53          ;Store InitMem register values and jump
0x0B9A AB 60      MOV R3,  X60h
0x0B9C AA 5F      MOV R2,  X5Fh
0x0B9E A9 5E      MOV R1,  X5Eh		; 32-bit timer counter  values?
0x0BA0 A8 5D      MOV R0,  X5Dh
0x0BA2 02 01 30   LJMP  0x0130              ; Do a lot a subtracting and LOR'ing and return value in A
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				Third Init Call routine for UART Setup
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0B03       
0x0BA5 C2 9F      CLR  SCON.7       ;Set 8 bit serial mode
0x0BA7 D2 9D      SETB  SCON.5      ;Only activate if stop bit is 1
0x0BA9 D2 9C      SETB  SCON.4      ;Enable serial reception
0x0BAB C2 99      CLR  SCON.1       ;Clear transmit interrupt flag
0x0BAD C2 98      CLR  SCON.0       ;Clear receieve interrupt flag
0x0BAF 22         RET               ; exit back to 0B06
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				SEND DPTR 1A00 = 03 OUT THE UART (start of 14th page)
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 07B2             
0x0BB0 7F 00      MOV R7,  #0x00
0x0BB2 7E 1A      MOV R6,  #0x1A
0x0BB4 12 0B 78   LCALL  0x0B78		; get data at dptr= 1A00 = 3 => R7
0x0BB7 02 00 46   LJMP  0x0046		; send R7 out the UART
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				Send Secondary Loop or RESET Vector out UART
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 07B5 		looking at 0BFF vs 0000
0x0BBA 7D FF      MOV R5,  #0xFF
0x0BBC 7C 0B      MOV R4,  #0x0B		; pointers to either secondary loop or RESET
0x0BBE E4         CLR A 			; FF 02 0D 2D  vs  02 04 1C 
0x0BBF FF         MOV R7, A 
0x0BC0 FE         MOV R6, A 
0x0BC1 02 0A AE   LJMP  0x0AAE		; send calc dptr hilo out the UART
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				Clear 32-bit timer/counter value 5D-60
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0A05 0909          ; Clear out the 32 bit counter stored at 0x5D - 0x60
0x0BC4 E4         CLR A 
0x0BC5 F5 60      MOV  X60h, A
0x0BC7 F5 5F      MOV  X5Fh, A
0x0BC9 F5 5E      MOV  X5Eh, A
0x0BCB F5 5D      MOV  X5Dh, A
0x0BCD 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				0A05 ret
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers:                    Sixth jump target in main loop jump table
0x0BCE 7F 21      MOV R7,  #0x21    ;R7 = 0x21
0x0BD0 12 07 74   LCALL  0x0774     ;XXX
0x0BD3 E4         CLR A             
0x0BD4 F5 69      MOV  X69h, A      ;Set main loop selector byte to 0
0x0BD6 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 076D 
0x0BD7 C2 9C      CLR  SCON.4
0x0BD9 C2 99      CLR  SCON.1
0x0BDB C2 98      CLR  SCON.0
0x0BDD 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;			;subroutine to allow Vdd resets, disable Flash W/E
; Jump Target - Callers: 09A1 
0x0BDE 75 FF 80   MOV  VDDMON, #0x80
0x0BE1 E4         CLR A 
0x0BE2 F5 8F      MOV  PSCTL, A
0x0BE4 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Data Table pointed from:  0399  088E 
0x0BE5            0x00          ; first state code
0x0BE6            0x01
0x0BE7            0x02
0x0BE8            0x03
0x0BE9            0x04
0x0BEA            0x05          ; sixth state code
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0x0BEB            0xFF
0x0BEC            0xFF
0x0BED            0xFF
0x0BEE            0xFF
0x0BEF            0xFF
0x0BF0            0xFF
0x0BF1            0xFF
0x0BF2            0xFF
0x0BF3            0xFF
0x0BF4            0xFF
0x0BF5            0xFF
0x0BF6            0xFF
0x0BF7            0xFF
0x0BF8            0xFF
0x0BF9            0xFF
0x0BFA            0xFF
0x0BFB            0xFF
0x0BFC            0xFF
0x0BFD            0xFF
0x0BFE            0xFF
0x0BFF            0xFF
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0770 
0x0C00 02 0D 2D   LJMP  0x0D2D		; [ start of secondary ?]
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 1260           - Set up PCA
0x0C03 E4         CLR A 
0x0C04 F5 D9      MOV  PCAMD, A         ; First, disable everything
0x0C06 75 EB FF   MOV  PCACPL2, #0xFF   ; Set low byte of capture module 2 to 0xFF
0x0C09 75 D9 60   MOV  PCAMD, #0x60     ; 0110 0000 = Module 2 enabled as watchdog timer, W/D timer locked on until reset
0x0C0C 22         RET
;0x0C0D            0xFF
;0x0C0E            0xFF
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				UART ISR
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0023 		; target of UART ISR	
0x0C0F 02 0D B9   LJMP  0x0DB9
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Timer2 O/F ISR
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; LJump Target - ljmp from: 002B      - Target of Timer2 Overflow ISR interrupt
0x0C12 02 11 0A   LJMP  0x110A
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				0C15 Data Table
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Data in FLASH Space                   ; from 101A
0x0C15            0x00
0x0C16            0x07
0x0C17            0x0E
0x0C18            0x09
0x0C19            0x1C
0x0C1A            0x1B
0x0C1B            0x12
0x0C1C            0x15
0x0C1D            0x38 (8)
0x0C1E            0x3F (?)
0x0C1F            0x36 (6)
0x0C20            0x31 (1)
0x0C21            0x24 ($)
0x0C22            0x23 (#)
0x0C23            0x2A (*)
0x0C24            0x2D (-)
0x0C25            0x70 (p)
0x0C26            0x77 (w)
0x0C27            0x7E (~)
0x0C28            0x79 (y)
0x0C29            0x6C (l)
0x0C2A            0x6B (k)
0x0C2B            0x62 (b)
0x0C2C            0x65 (e)
0x0C2D            0x48 (H)
0x0C2E            0x4F (O)
0x0C2F            0x46 (F)
0x0C30            0x41 (A)
0x0C31            0x54 (T)
0x0C32            0x53 (S)
0x0C33            0x5A (Z)
0x0C34            0x5D (])
0x0C35            0xE0
0x0C36            0xE7
0x0C37            0xEE
0x0C38            0xE9
0x0C39            0xFC
0x0C3A            0xFB
0x0C3B            0xF2
0x0C3C            0xF5
0x0C3D            0xD8
0x0C3E            0xDF
0x0C3F            0xD6
0x0C40            0xD1
0x0C41            0xC4
0x0C42            0xC3
0x0C43            0xCA
0x0C44            0xCD
0x0C45            0x90
0x0C46            0x97
0x0C47            0x9E
0x0C48            0x99
0x0C49            0x8C
0x0C4A            0x8B
0x0C4B            0x82
0x0C4C            0x85
0x0C4D            0xA8
0x0C4E            0xAF
0x0C4F            0xA6
0x0C50            0xA1
0x0C51            0xB4
0x0C52            0xB3
0x0C53            0xBA
0x0C54            0xBD
0x0C55            0xC7
0x0C56            0xC0
0x0C57            0xC9
0x0C58            0xCE
0x0C59            0xDB
0x0C5A            0xDC
0x0C5B            0xD5
0x0C5C            0xD2
0x0C5D            0xFF
0x0C5E            0xF8
0x0C5F            0xF1
0x0C60            0xF6
0x0C61            0xE3
0x0C62            0xE4
0x0C63            0xED
0x0C64            0xEA
0x0C65            0xB7
0x0C66            0xB0
0x0C67            0xB9
0x0C68            0xBE
0x0C69            0xAB
0x0C6A            0xAC
0x0C6B            0xA5
0x0C6C            0xA2
0x0C6D            0x8F
0x0C6E            0x88
0x0C6F            0x81
0x0C70            0x86
0x0C71            0x93
0x0C72            0x94
0x0C73            0x9D
0x0C74            0x9A
0x0C75            0x27 (')
0x0C76            0x20 ( )
0x0C77            0x29 ())
0x0C78            0x2E (.)
0x0C79            0x3B (;)
0x0C7A            0x3C (<)
0x0C7B            0x35 (5)
0x0C7C            0x32 (2)
0x0C7D            0x1F
0x0C7E            0x18
0x0C7F            0x11
0x0C80            0x16
0x0C81            0x03
0x0C82            0x04
0x0C83            0x0D
0x0C84            0x0A
0x0C85            0x57 (W)
0x0C86            0x50 (P)
0x0C87            0x59 (Y)
0x0C88            0x5E (^)
0x0C89            0x4B (K)
0x0C8A            0x4C (L)
0x0C8B            0x45 (E)
0x0C8C            0x42 (B)
0x0C8D            0x6F (o)
0x0C8E            0x68 (h)
0x0C8F            0x61 (a)
0x0C90            0x66 (f)
0x0C91            0x73 (s)
0x0C92            0x74 (t)
0x0C93            0x7D (})
0x0C94            0x7A (z)
0x0C95            0x89
0x0C96            0x8E
0x0C97            0x87
0x0C98            0x80
0x0C99            0x95
0x0C9A            0x92
0x0C9B            0x9B
0x0C9C            0x9C
0x0C9D            0xB1
0x0C9E            0xB6
0x0C9F            0xBF
0x0CA0            0xB8
0x0CA1            0xAD
0x0CA2            0xAA
0x0CA3            0xA3
0x0CA4            0xA4
0x0CA5            0xF9
0x0CA6            0xFE
0x0CA7            0xF7
0x0CA8            0xF0
0x0CA9            0xE5
0x0CAA            0xE2
0x0CAB            0xEB
0x0CAC            0xEC
0x0CAD            0xC1
0x0CAE            0xC6
0x0CAF            0xCF
0x0CB0            0xC8
0x0CB1            0xDD
0x0CB2            0xDA
0x0CB3            0xD3
0x0CB4            0xD4
0x0CB5            0x69 (i)
0x0CB6            0x6E (n)
0x0CB7            0x67 (g)
0x0CB8            0x60 (`)
0x0CB9            0x75 (u)
0x0CBA            0x72 (r)
0x0CBB            0x7B ({)
0x0CBC            0x7C (|)
0x0CBD            0x51 (Q)
0x0CBE            0x56 (V)
0x0CBF            0x5F (_)
0x0CC0            0x58 (X)
0x0CC1            0x4D (M)
0x0CC2            0x4A (J)
0x0CC3            0x43 (C)
0x0CC4            0x44 (D)
0x0CC5            0x19
0x0CC6            0x1E
0x0CC7            0x17
0x0CC8            0x10
0x0CC9            0x05
0x0CCA            0x02
0x0CCB            0x0B
0x0CCC            0x0C
0x0CCD            0x21 (!)
0x0CCE            0x26 (&)
0x0CCF            0x2F (/)
0x0CD0            0x28 (()
0x0CD1            0x3D (=)
0x0CD2            0x3A (:)
0x0CD3            0x33 (3)
0x0CD4            0x34 (4)
0x0CD5            0x4E (N)
0x0CD6            0x49 (I)
0x0CD7            0x40 (@)
0x0CD8            0x47 (G)
0x0CD9            0x52 (R)
0x0CDA            0x55 (U)
0x0CDB            0x5C (\)
0x0CDC            0x5B ([)
0x0CDD            0x76 (v)
0x0CDE            0x71 (q)
0x0CDF            0x78 (x)
0x0CE0            0x7F ()
0x0CE1            0x6A (j)
0x0CE2            0x6D (m)
0x0CE3            0x64 (d)
0x0CE4            0x63 (c)
0x0CE5            0x3E (>)
0x0CE6            0x39 (9)
0x0CE7            0x30 (0)
0x0CE8            0x37 (7)
0x0CE9            0x22 (")
0x0CEA            0x25 (%)
0x0CEB            0x2C (,)
0x0CEC            0x2B (+)
0x0CED            0x06
0x0CEE            0x01
0x0CEF            0x08
0x0CF0            0x0F
0x0CF1            0x1A
0x0CF2            0x1D
0x0CF3            0x14
0x0CF4            0x13
0x0CF5            0xAE
0x0CF6            0xA9
0x0CF7            0xA0
0x0CF8            0xA7
0x0CF9            0xB2
0x0CFA            0xB5
0x0CFB            0xBC
0x0CFC            0xBB
0x0CFD            0x96
0x0CFE            0x91
0x0CFF            0x98
0x0D00            0x9F
0x0D01            0x8A
0x0D02            0x8D
0x0D03            0x84
0x0D04            0x83
0x0D05            0xDE
0x0D06            0xD9
0x0D07            0xD0
0x0D08            0xD7
0x0D09            0xC2
0x0D0A            0xC5
0x0D0B            0xCC
0x0D0C            0xCB
0x0D0D            0xE6
0x0D0E            0xE1
0x0D0F            0xE8
0x0D10            0xEF
0x0D11            0xFA
0x0D12            0xFD
0x0D13            0xF4
0x0D14            0xF3
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;                               ; this jump table is spaced x0100 above the dptr data table (ref 10FF)
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0x0D15            0xFF          ;Here starts the secondary set of jump table targets FF in between each is ignored
0x0D16            0x10          ;First target = 0x102A
0x0D17            0x2A 
0x0D18            0xFF
0x0D19            0x0F          ;Second target = 0xF27
0x0D1A            0x27 
0x0D1B            0xFF
0x0D1C            0x11          ;Third Target = 0x1154
0x0D1D            0x54 
0x0D1E            0xFF
0x0D1F            0x10          ;Fourth target = 0x10B8
0x0D20            0xB8
0x0D21            0xFF
0x0D22            0x11          ;Five target = 0x1175
0x0D23            0x75 
0x0D24            0xFF
0x0D25            0x11          ;Sixth Target = 0x11EB
0x0D26            0xEB
0x0D27            0xFF
0x0D28            0x12          ;Seventh target = 0x1279
0x0D29            0x79 
0x0D2A            0xFF
0x0D2B            0x10          ;Eighth/Final target = 0x105E
0x0D2C            0x5E 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Secondary ClearRAM  [looks like reset]
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0C00               ; Set up to clear RAM from 0 to 0x7F
0x0D2D 78 7F      MOV R0,  #0x7F
0x0D2F E4         CLR A 
;
; loop - Callers: 0D31               
0x0D30 F6         MOV @R0, A               
0x0D31 D8 FD      DJNZ R0,  0x0D30          
0x0D33 75 81 42   MOV  SP, #0x42            ; Then set stack pointer to 0x42
0x0D36 02 0D 74   LJMP  0x0D74              ; jump to SecondaryInitMem
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0D7B 		; Return from Secondary InitMem
0x0D39 02 11 B5   LJMP  0x11B5		; jump to 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				Generic dptr read to init memory RAM registers
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0D92 
0x0D3C E4         CLR A 
0x0D3D 93         MOVC A, @A+DPTR 
0x0D3E A3         INC DPTR 
0x0D3F F8         MOV R0, A 
;
; LOOP - Callers: 0D4A 
0x0D40 E4         CLR A 
0x0D41 93         MOVC A, @A+DPTR 
0x0D42 A3         INC DPTR 
0x0D43 40 03      JC  0x0D48
0x0D45 F6         MOV @R0, A 
0x0D46 80 01      SJMP  0x0D49
;
; Jump Target - Callers: 0D43 
0x0D48 F2         MOVX @R0, A 
;
; Jump Target - Callers: 0D46 
0x0D49 08         INC R0 
0x0D4A DF F4      DJNZ R7,  0x0D40
0x0D4C 80 29      SJMP  0x0D77
;
; Jump Target - Callers: 0D94 0D68 	; [obscure meaning]
0x0D4E E4         CLR A 
0x0D4F 93         MOVC A, @A+DPTR           ;A is cleared so grab byte just at DPTR
0x0D50 A3         INC DPTR                  ;And increment DPTR afterward
0x0D51 F8         MOV R0, A                 ;then store value into R0
0x0D52 54 07      ANL A,  #0x07             ;mask to just bottom three bits
0x0D54 24 0C      ADD A,  #0x0C             ;Then set top 2 bits
0x0D56 C8         XCH A, R0                 ;Swap Accum and R0 (Now R0 is the masked version)
0x0D57 C3         CLR C                     ;clear carry
0x0D58 33         RLC A                     ;Rotate accum left one bit (Set carry if accum had bit 7 set)
0x0D59 C4         SWAP A                    ;Swap upper and lower nibbles of accum
0x0D5A 54 0F      ANL A,  #0x0F             ;Then mask to only the low nibble
0x0D5C 44 20      ORL A,  #0x20             ;set bit 5
0x0D5E C8         XCH A, R0                 ;Swap accum and R0 (now accum is back to the masked version from above)
0x0D5F 83         MOVC A, @A+PC             ;Grab byte (Accum) bytes ahead from this point (start of table is 0xC bytes ahead)
0x0D60 40 04      JC  0x0D66                ;Jump to 0xD66 if carry bit set (if accum had bit 7 set before left shift above)        
0x0D62 F4         CPL A                     ;A = NOT A (bitwise not)
0x0D63 56         ANL A, @R0                ;Accum AND (Value pointed to in RAM by R0)
0x0D64 80 01      SJMP  0x0D67              ;skip ORL instruction
;
; Jump Target - Callers: 0D60 
0x0D66 46         ORL A, @R0 
;
; Jump Target - Callers: 0D64 
0x0D67 F6         MOV @R0, A                ;Set RAM pointed to by R0 to value from Accum
0x0D68 DF E4      DJNZ R7,  0x0D4E          ;Dec D7 and jump if it isn't zero
0x0D6A 80 0B      SJMP  0x0D77              ;skip over data table and setting of DPTR
;
; Data in FLASH Space                       ; the obscure meaning data table again
0x0D6C            0x01
0x0D6D            0x02
0x0D6E            0x04
0x0D6F            0x08
0x0D70            0x10
0x0D71            0x20 
0x0D72            0x40 
0x0D73            0x80
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Secondary InitMem
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
SecondaryInitMem:  from: 0D36		; This looks like repeat of StartInitMem at 0463
0x0D74 90 12 45   MOV DPTR,  #0x1245        ; RAM register load table at 0x1245
;					; fall thru
; Jump Target - Callers: 0D4C 0D6A 0DB7 	; reader section  and loop returns
0x0D77 E4         CLR A                   		identical section, see notes at x0466
0x0D78 7E 01      MOV R6,  #0x01
0x0D7A 93         MOVC A, @A+DPTR           
0x0D7B 60 BC      JZ  0x0D39 		; EXITS HERE               
0x0D7D A3         INC DPTR                  
0x0D7E FF         MOV R7, A                 
0x0D7F 54 3F      ANL A,  #0x3F             
0x0D81 30 E5 09   JNB  ACC.5, 0x0D8D        
0x0D84 54 1F      ANL A,  #0x1F             
0x0D86 FE         MOV R6, A                 
0x0D87 E4         CLR A                     
0x0D88 93         MOVC A, @A+DPTR           
0x0D89 A3         INC DPTR                  
0x0D8A 60 01      JZ  0x0D8D                
0x0D8C 0E         INC R6                    
;
; Jump Target - Callers: 0D81 0D8A 
0x0D8D CF         XCH A, R7                 ; Accum and R7 trade places
0x0D8E 54 C0      ANL A,  #0xC0             ; mask to just keep top two bits of accum
0x0D90 25 E0      ADD A,  ACC               ; Multiply by two
0x0D92 60 A8      JZ  0x0D3C                ; If it's zero jump to 0xD3C
0x0D94 40 B8      JC  0x0D4E                ; If it overflowed (bit 7 must have been set...) jump to 0xD4E
0x0D96 E4         CLR A             
0x0D97 93         MOVC A, @A+DPTR           ; As always, set A to zero then use just DPTR to look up a new byte
0x0D98 A3         INC DPTR                  ; Also as always, increment DPTR afterward
0x0D99 FA         MOV R2, A                 ; store result into R2
0x0D9A E4         CLR A 
0x0D9B 93         MOVC A, @A+DPTR           ; Grab another byte from DPTR
0x0D9C A3         INC DPTR                  ; Inc DPTR again
0x0D9D F8         MOV R0, A                 ; Store that byte into R0
;
; loop - Callers: 0DB3 0DB5 
0x0D9E E4         CLR A 
0x0D9F 93         MOVC A, @A+DPTR           ; Grab another byte from DPTR
0x0DA0 A3         INC DPTR                  ; Inc DPTR again
0x0DA1 C8         XCH A, R0                 ; Swap R0 and Accum
0x0DA2 C5 82      XCH A,  DPL               ; Swap Accum and DPL (DPL = value R0 had)
0x0DA4 C8         XCH A, R0                 ; Swap R0 and Accum (R0 now has old value from DPL)
0x0DA5 CA         XCH A, R2                 ; Swap Accum and R2
0x0DA6 C5 83      XCH A,  DPH               ; Swap accum and DPH (DPH = value R2 had)
0x0DA8 CA         XCH A, R2                 ; Swap Accum and R2 (R2 now has old value from DPH)
0x0DA9 F0         MOVX @DPTR, A             ; XDATA write to DPTR with value in accum
0x0DAA A3         INC DPTR                  ; Inc DPTR again
0x0DAB C8         XCH A, R0                 ; Swap Accum and R0  - Basically we're reversing the above lines that set DPH/DPL to new values
0x0DAC C5 82      XCH A,  DPL               ; Swap Accum and DPL
0x0DAE C8         XCH A, R0                 ; Swap Accum and R0
0x0DAF CA         XCH A, R2                 ; Swap accum and R2
0x0DB0 C5 83      XCH A,  DPH               ; Swap Accum and DPH
0x0DB2 CA         XCH A, R2                 ; Swap accum and R2
0x0DB3 DF E9      DJNZ R7,  0x0D9E          ;If either R7 or R6 is not zero when one is subtracted
0x0DB5 DE E7      DJNZ R6,  0x0D9E          ;then jump to 0xD9E
0x0DB7 80 BE      SJMP  0x0D77              ;If they both were 0 then jump to 0xD77
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				UART INTERRUPT SERVICE ROUTINE
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0C0F 
0x0DB9 C0 E0      PUSH  ACC
0x0DBB C0 F0      PUSH  B
0x0DBD C0 83      PUSH  DPH
0x0DBF C0 82      PUSH  DPL
0x0DC1 C0 D0      PUSH  PSW
0x0DC3 75 D0 00   MOV  PSW, #0x00
0x0DC6 C0 00      PUSH  R0
0x0DC8 C0 01      PUSH  R1
0x0DCA C0 02      PUSH  R2
0x0DCC C0 03      PUSH  R3
0x0DCE C0 04      PUSH  R4
0x0DD0 C0 05      PUSH  R5
0x0DD2 C0 06      PUSH  R6
0x0DD4 C0 07      PUSH  R7
0x0DD6 30 99 05   JNB  SCON.1, 0x0DDE
0x0DD9 75 2B 00   MOV  X2Bh, #0x00
0x0DDC C2 99      CLR  SCON.1
;
; Jump Target - Callers: 0DD6 
0x0DDE 30 98 30   JNB  SCON.0, 0x0E11
0x0DE1 85 99 2A   MOV  X2Ah, SBUF
0x0DE4 E5 2C      MOV A,  X2Ch
0x0DE6 60 21      JZ  0x0E09
0x0DE8 E5 2B      MOV A,  X2Bh
0x0DEA 60 05      JZ  0x0DF1
;
; WAIT LOOP - Callers: 0DEC 
0x0DEC 30 99 FD   JNB  SCON.1, 0x0DEC
0x0DEF C2 99      CLR  SCON.1
;
; Jump Target - Callers: 0DEA 
0x0DF1 E5 2D      MOV A,  X2Dh
0x0DF3 60 0D      JZ  0x0E02
0x0DF5 E5 2A      MOV A,  X2Ah
0x0DF7 54 FE      ANL A,  #0xFE
0x0DF9 70 07      JNZ  0x0E02
0x0DFB E5 2A      MOV A,  X2Ah
0x0DFD 44 80      ORL A,  #0x80
0x0DFF FF         MOV R7, A 
0x0E00 80 02      SJMP  0x0E04
;
; Jump Target - Callers: 0DF3 0DF9 
0x0E02 AF 2A      MOV R7,  X2Ah
;
; Jump Target - Callers: 0E00 
0x0E04 8F 99      MOV  SBUF, R7
0x0E06 75 2B 01   MOV  X2Bh, #0x01
;
; Jump Target - Callers: 0DE6 
0x0E09 75 29 01   MOV  X29h, #0x01
0x0E0C C2 98      CLR  SCON.0
0x0E0E 12 12 95   LCALL  0x1295		; clear RAM 23-26
;
; Jump Target - Callers: 0DDE 
0x0E11 D0 07      POP  R7
0x0E13 D0 06      POP  R6
0x0E15 D0 05      POP  R5
0x0E17 D0 04      POP  R4
0x0E19 D0 03      POP  R3
0x0E1B D0 02      POP  R2
0x0E1D D0 01      POP  R1
0x0E1F D0 00      POP  R0
0x0E21 D0 D0      POP  PSW
0x0E23 D0 82      POP  DPL
0x0E25 D0 83      POP  DPH
0x0E27 D0 F0      POP  B
0x0E29 D0 E0      POP  ACC
0x0E2B 32         RETI 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				Return from Interrupt
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				generic (compiler) READ duplicate of 008E
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0FDD 0EAA 1013      ; many data access strategies, one routine. 
0x0E2C BB 01 0C   CJNE R3,  #0x01, 0x0E3B    ;If R3 = 1 Add R1 to DPL, R2 to DPH then grab byte at @DPTR and return it in Accum
0x0E2F E5 82      MOV A,  DPL
0x0E31 29         ADD A, R1 
0x0E32 F5 82      MOV  DPL, A
0x0E34 E5 83      MOV A,  DPH
0x0E36 3A         ADDC A, R2 
0x0E37 F5 83      MOV  DPH, A
0x0E39 E0         MOVX A, @DPTR 		; read from XRam at dptr
0x0E3A 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0E2C               ; If R3 wasn't 1
0x0E3B 50 06      JNC  0x0E43               ; if the carry bit was set 
0x0E3D E9         MOV A, R1                 ; Add R1 to DPL
0x0E3E 25 82      ADD A,  DPL
0x0E40 F8         MOV R0, A                 ; Move accum to R0
0x0E41 E6         MOV A, @R0                ; Do indirect byte lookup and store in accum
0x0E42 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0E3B               ; R3 != 1 and carry bit =0 then do this
0x0E43 BB FE 06   CJNE R3,  #0xFE, 0x0E4C		; if R3 = -2?
0x0E46 E9         MOV A, R1 
0x0E47 25 82      ADD A,  DPL
0x0E49 F8         MOV R0, A 
0x0E4A E2         MOVX, A, @R0 		; read from XRam at R0 pointer
0x0E4B 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
; Jump Target - Callers: 0E43 		; for R3 != -2 and C =0
;
0x0E4C E5 82      MOV A,  DPL
0x0E4E 29         ADD A, R1 
0x0E4F F5 82      MOV  DPL, A
0x0E51 E5 83      MOV A,  DPH
0x0E53 3A         ADDC A, R2 
0x0E54 F5 83      MOV  DPH, A
0x0E56 E4         CLR A 
0x0E57 93         MOVC A, @A+DPTR 	; read from flash at dptr
0x0E58 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				generic WRITE  duplicate of 
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0F1C 
0x0E59 BB 01 06   CJNE R3,  #0x01, 0x0E62
0x0E5C 89 82      MOV  DPL, R1
0x0E5E 8A 83      MOV  DPH, R2
0x0E60 F0         MOVX @DPTR, A 			; write to flash or XMem at dptr
0x0E61 22         RET 

; Jump Target - Callers: 0E59 
0x0E62 50 02      JNC  0x0E66
0x0E64 F7         MOV @R1, A 			; write to RAM register
0x0E65 22         RET 

; Jump Target - Callers: 0E62 
0x0E66 BB FE 01   CJNE R3,  #0xFE, 0x0E6A
0x0E69 F3         MOVX @R1, A 			; write to XRAM register

; Jump Target - Callers: 0E66 
0x0E6A 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				16-bit Math with LOR  duplicate of 0130
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 1239 0F08 
0x0E6B EB         MOV A, R3 
0x0E6C 9F         SUBB A, R7 
0x0E6D F5 F0      MOV  B, A
0x0E6F EA         MOV A, R2 
0x0E70 9E         SUBB A, R6 
0x0E71 42 F0      ORL  B, A
0x0E73 E9         MOV A, R1 
0x0E74 9D         SUBB A, R5 
0x0E75 42 F0      ORL  B, A
0x0E77 E8         MOV A, R0 
0x0E78 9C         SUBB A, R4 
0x0E79 45 F0      ORL A,  B
0x0E7B 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				Transfer Program Control Jump at DPTR
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 1105 		; jump table transfer of
0x0E7C 8A 83      MOV  DPH, R2
0x0E7E 89 82      MOV  DPL, R1
0x0E80 E4         CLR A 
0x0E81 73         JMP @A+DPTR 		; program control
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;
;				SPI and UART activity ?
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 1281 
0x0E82 8B 2F      MOV  X2Fh, R3         ; push gp R1-R3 to RAM
0x0E84 8A 30      MOV  X30h, R2
0x0E86 89 31      MOV  X31h, R1
0x0E88 E4         CLR A 
0x0E89 F5 33      MOV  X33h, A          ; clear RAM 0x33
0x0E8B FF         MOV R7, A             ; clear R7 to 0
0x0E8C 12 12 BF   LCALL  0x12BF         ; Gets RAM 0x2C (flag for forwarding UART traffic) and puts it in R7
0x0E8F 7F 01      MOV R7,  #0x01        ; Oddly enough, set R7 to 1 right after that.
0x0E91 12 12 9F   LCALL  0x129F         ; Set state of CS (if R7 is 1 then CS goes Low)
0x0E94 AB 2F      MOV R3,  X2Fh         ; pop gp registers
0x0E96 AA 30      MOV R2,  X30h
0x0E98 A9 31      MOV R1,  X31h
0x0E9A 7D 03      MOV R5,  #0x03        ; load R4 and R5
0x0E9C 7C 00      MOV R4,  #0x00
0x0E9E 12 0F B6   LCALL  0x0FB6         ; Do Flash dptr reading and send those bytes out SPI
;
; loop Target - Callers: 0ECA 
0x0EA1 AB 2F      MOV R3,  X2Fh		; loop
0x0EA3 AA 30      MOV R2,  X30h
0x0EA5 A9 31      MOV R1,  X31h
0x0EA7 90 00 02   MOV DPTR,  #0x0002
0x0EAA 12 0E 2C   LCALL  0x0E2C         ; read data based upon R3, C, R1,R2, flash, Ram, XRam
;				; Add R1 to DPL, R2 to DPH then grab byte at @DPTR and return it in Accum 
0x0EAD 24 01      ADD A,  #0x01         ; Add 1 to resultant byte
0x0EAF FF         MOV R7, A             ; Store it in R7
0x0EB0 E4         CLR A                 ; clear accum
0x0EB1 33         RLC A                 ; Rotate carry flag into bit 0
0x0EB2 FE         MOV R6, A             ; Store that value into R6 (its going to either be 0 or 1)
0x0EB3 C3         CLR C                 ; clear the carry flag now
0x0EB4 E5 33      MOV A,  X33h          ; Grab RAM 0x33 and put it in Accum
0x0EB6 9F         SUBB A, R7            ; Subtract R7 from value we got from RAM 0x33
0x0EB7 EE         MOV A, R6             ; Put R6 value into accum
0x0EB8 64 80      XRL A,  #0x80         ; XOR accum with 1000 0000
0x0EBA F8         MOV R0, A             ; Put value into R0
0x0EBB 74 80      MOV A,  #0x80         ; Set accum to 0x80
0x0EBD 98         SUBB A, R0            ; Subtract R0 from 0x80
0x0EBE 50 0C      JNC  0x0ECC           ; goto 0xECC if we didn't carry (if R0 was less than 0x80)
;
0x0EC0 12 11 96   LCALL  0x1196         ;
;
0x0EC3 8F 32      MOV  X32h, R7         ; Store value we're about to transmit in RAM 0x32
0x0EC5 12 12 69   LCALL  0x1269         ; transmit byte in R7 out UART
0x0EC8 05 33      INC  X33h             ; Increment RAM 0x33 maybe as some sent byte counter or something.
0x0ECA 80 D5      SJMP  0x0EA1          ; Jump back to the start of this section (0x0EA1) any time code gets this far.
;
; Jump Target - Callers: 0EBE 
0x0ECC E4         CLR A 
0x0ECD FF         MOV R7, A 
0x0ECE 12 12 9F   LCALL  0x129F		; set state of CS from R7
0x0ED1 7F 01      MOV R7,  #0x01
0x0ED3 12 12 BF   LCALL  0x12BF		; Gets RAM 0x2C (flag for forwarding UART traffic) and puts it in R7
0x0ED6 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				push gp, clear 23-26, read serial?
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 0F3A 1162 10C6 1183 
0x0ED7 8B 16      MOV  X16h, R3
0x0ED9 8A 17      MOV  X17h, R2
0x0EDB 89 18      MOV  X18h, R1		; push gp registers
0x0EDD 8F 1C      MOV  X1Ch, R7
0x0EDF 8E 1B      MOV  X1Bh, R6
0x0EE1 8D 1A      MOV  X1Ah, R5
0x0EE3 8C 19      MOV  X19h, R4
0x0EE5 12 12 95   LCALL  0x1295		; clear RAM 23-26
;
; Jump Target - Callers: 0EF8 0F0B 
0x0EE8 E5 29      MOV A,  X29h
0x0EEA 70 24      JNZ  0x0F10
0x0EEC AF 1C      MOV R7,  X1Ch
0x0EEE AE 1B      MOV R6,  X1Bh
0x0EF0 AD 1A      MOV R5,  X1Ah
0x0EF2 AC 19      MOV R4,  X19h
0x0EF4 12 12 30   LCALL  0x1230		; 
0x0EF7 EF         MOV A, R7 
0x0EF8 60 EE      JZ  0x0EE8
0x0EFA E4         CLR A 
0x0EFB FF         MOV R7, A 
0x0EFC FE         MOV R6, A 
0x0EFD FD         MOV R5, A 
0x0EFE FC         MOV R4, A 
0x0EFF AB 1C      MOV R3,  X1Ch
0x0F01 AA 1B      MOV R2,  X1Bh
0x0F03 A9 1A      MOV R1,  X1Ah
0x0F05 A8 19      MOV R0,  X19h
0x0F07 C3         CLR C 
0x0F08 12 0E 6B   LCALL  0x0E6B		; 
0x0F0B 60 DB      JZ  0x0EE8
0x0F0D 7F 02      MOV R7,  #0x02
0x0F0F 22         RET 
;
; Jump Target - Callers: 0EEA 
0x0F10 C2 AF      CLR  IE.7
0x0F12 C2 AF      CLR  IE.7
0x0F14 AB 16      MOV R3,  X16h
0x0F16 AA 17      MOV R2,  X17h
0x0F18 A9 18      MOV R1,  X18h
0x0F1A E5 2A      MOV A,  X2Ah
0x0F1C 12 0E 59   LCALL  0x0E59		;
0x0F1F E4         CLR A 
0x0F20 F5 29      MOV  X29h, A
0x0F22 D2 AF      SETB  IE.7
0x0F24 7F 01      MOV R7,  #0x01
0x0F26 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				2nd Jump Target in [Secondary] loop
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers:              
0x0F27 7F 01      MOV R7,  #0x01
0x0F29 12 12 B9   LCALL  0x12B9		; 
0x0F2C 7B 00      MOV R3,  #0x00
0x0F2E 7A 00      MOV R2,  #0x00
0x0F30 79 3D      MOV R1,  #0x3D
0x0F32 7F 00      MOV R7,  #0x00
0x0F34 7E 00      MOV R6,  #0x00
0x0F36 7D 00      MOV R5,  #0x00
0x0F38 7C 00      MOV R4,  #0x00
0x0F3A 12 0E D7   LCALL  0x0ED7		; 
0x0F3D EF         MOV A, R7 
0x0F3E 64 01      XRL A,  #0x01
0x0F40 60 07      JZ  0x0F49
0x0F42 E4         CLR A 
0x0F43 F5 1D      MOV  X1Dh, A
0x0F45 FF         MOV R7, A 
0x0F46 02 12 BC   LJMP  0x12BC		; 
;
; Jump Target - Callers: 0F40 
0x0F49 D2 93      SETB  P1.3
0x0F4B E4         CLR A 
0x0F4C FF         MOV R7, A 
0x0F4D 12 12 BC   LCALL  0x12BC
0x0F50 E5 3D      MOV A,  X3Dh
0x0F52 54 FE      ANL A,  #0xFE
0x0F54 FF         MOV R7, A 
0x0F55 65 1E      XRL A,  X1Eh
0x0F57 60 03      JZ  0x0F5C
0x0F59 BF 7E 08   CJNE R7,  #0x7E, 0x0F64
;
; Jump Target - Callers: 0F57 
0x0F5C 85 3D 1F   MOV  X1Fh, X3Dh
0x0F5F 75 1D 02   MOV  X1Dh, #0x02
0x0F62 80 08      SJMP  0x0F6C
;
; Jump Target - Callers: 0F59 
0x0F64 E5 3D      MOV A,  X3Dh
0x0F66 54 C0      ANL A,  #0xC0
0x0F68 FF         MOV R7, A 
0x0F69 E4         CLR A 
0x0F6A F5 1D      MOV  X1Dh, A
;
; Jump Target - Callers: 0F62 
0x0F6C E4         CLR A 
0x0F6D FF         MOV R7, A 
0x0F6E 12 12 B9   LCALL  0x12B9
0x0F71 22         RET
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				SPI, WRITE AND READ READ
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 11C6 
0x0F72 E4         CLR A 
0x0F73 F5 0F      MOV  X0Fh, A          ;Clear out RAM 0x0F and 0x13
0x0F75 F5 13      MOV  X13h, A
0x0F77 75 14 01   MOV  X14h, #0x01      ;Set RAM 0x14 to 1
;
; loop Target - Callers: 0FB3 
0x0F7A E5 0F      MOV A,  X0Fh          ; Grab value at RAM 0xF
0x0F7C 25 E0      ADD A,  ACC           ; Multiply by 2
0x0F7E F5 12      MOV  X12h, A          ; Store it at RAM 0x12
0x0F80 7F 01      MOV R7,  #0x01        ; Set R7 = 1
0x0F82 12 12 9F   LCALL  0x129F         ; R7=0 means set Chip Sel high, otherwise set CS Low
0x0F85 7B 00      MOV R3,  #0x00
0x0F87 7A 00      MOV R2,  #0x00
0x0F89 79 12      MOV R1,  #0x12        ; lots of register setting to static values
0x0F8B 7D 03      MOV R5,  #0x03
0x0F8D 7C 00      MOV R4,  #0x00
0x0F8F 12 0F B6   LCALL  0x0FB6         ; read data from pointer location and send out SPI 
;
0x0F92 12 11 96   LCALL  0x1196         ; SPI read routine. Clock out a zero byte and get reply back - returned in R7
;
0x0F95 8F 10      MOV  X10h, R7         ; Store the SPI reply in RAM 0x10
0x0F97 12 11 96   LCALL  0x1196         ; That same SPI read routine again
0x0F9A 8F 11      MOV  X11h, R7         ; store this reply byte into RAM 0x11
0x0F9C E4         CLR A 
0x0F9D FF         MOV R7, A             ; set R7 = 0
0x0F9E 12 12 9F   LCALL  0x129F         ; Set CS to HIGH (Since R7 = 0)
0x0FA1 E5 11      MOV A,  X11h          ; Get that second value we got from SPI
0x0FA3 60 07      JZ  0x0FAC            ; compare RAM 0xF with value we put in RAM 0x11 maybe loop back to F7A
0x0FA5 E5 0F      MOV A,  X0Fh          ; If we didn't jump then grab value from RAM 0xF
0x0FA7 25 E0      ADD A,  ACC           ; Multiply it by two
0x0FA9 F5 1E      MOV  X1Eh, A          ; store it at RAM 0x1E
0x0FAB 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
; Jump Target - Callers: 0FA3 
0x0FAC 05 0F      INC  X0Fh             ; Increment value at RAM 0xF
0x0FAE E5 0F      MOV A,  X0Fh          ; Set that value into accum
0x0FB0 C3         CLR C                 ; clear carry
0x0FB1 94 11      SUBB A,  #0x11        ; subtract RAM 0x11 from A
0x0FB3 40 C5      JC  0x0F7A            ; If A was less than RAM 0x11 then jump to 0xF7A
0x0FB5 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				READS DATA FROM LOCATION AND SENDS IT OUT SPI
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 0F8F 0E9E 10A3 	; called from 
0x0FB6 8B 34      MOV  X34h, R3            ;[0] ;backup or push values in R1 - R5
0x0FB8 8A 35      MOV  X35h, R2
0x0FBA 89 36      MOV  X36h, R1		;[1f]
0x0FBC 8C 37      MOV  X37h, R4
0x0FBE 8D 38      MOV  X38h, R5		;[04]
0x0FC0 E4         CLR A                     ;clear R6 and R7 without saving prior values
0x0FC1 FF         MOV R7, A 
0x0FC2 FE         MOV R6, A 
0x0FC3 C2 AF      CLR  IE.7                 ;globally stop interrupts
0x0FC5 C2 AF      CLR  IE.7
;
; Jump Target - Callers: 0FE7 
0x0FC7 C3         CLR C                     ; Clear carry
0x0FC8 EF         MOV A, R7                 ; Copy R7 to accum
0x0FC9 95 38      SUBB A,  X38h             ; Subtract value from RAM 0x38 (Which was R5)
0x0FCB EE         MOV A, R6                 ; Copy R6 to accum
0x0FCC 95 37      SUBB A,  X37h             ; Subtract value from RAM 0x37 (Which was R4)
0x0FCE 50 19      JNC  0x0FE9               ; If carry bit not set then go to 0x0FE9
;
; Jump Target - Callers: 0FD0 
0x0FD0 30 F9 FD   JNB  SPICN.1, 0x0FD0      ; Wait until SPI is not writing
0x0FD3 AB 34      MOV R3,  X34h             ; Restore value of R1 - R3 from where they were backed up in RAM
0x0FD5 AA 35      MOV R2,  X35h
0x0FD7 A9 36      MOV R1,  X36h
0x0FD9 8F 82      MOV  DPL, R7              ; Set DPTR from R6:R7
0x0FDB 8E 83      MOV  DPH, R6
;
0x0FDD 12 0E 2C   LCALL  0x0E2C             ; read data based upon R3, C, R1,R2, from flash, Ram, or XRam
; Adds R1 to DPL, R2 to DPH then grabs byte at @DPTR and returns it in Accum
;
0x0FE0 F5 A3      MOV  SPIDAT, A            ; [Write value from Accum out SPI]
0x0FE2 0F         INC R7                    ; Increment R7 [dpl to read next byte]
0x0FE3 BF 00 01   CJNE R7,  #0x00, 0x0FE7   ; If R7 isn't 0 then skip the R6 increment below
0x0FE6 0E         INC R6 
;
; Jump Target - Callers: 0FE3 
0x0FE7 80 DE      SJMP  0x0FC7              ; Go back up to 0xFC7 (keep cycling until 0xFCE above triggers)
;
; Jump Target - Callers: 0FCE 0FEB 	; no borrow needed
0x0FE9 E5 A1      MOV A,  SPICFG            ; Grab SPI status
0x0FEB 20 E7 FB   JB  ACC.7, 0x0FE9         ; Is SPI busy flag set? Wait then.
0x0FEE D2 AF      SETB  IE.7                ; Re-enable global interrupts
0x0FF0 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				TABLE READ 0C15 FROM 6TH BRANCH OF SECONDARY LOOP
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 11F5 		
0x0FF1 8B 08      MOV  X08h, R3
0x0FF3 8A 09      MOV  X09h, R2
0x0FF5 89 0A      MOV  X0Ah, R1
0x0FF7 8C 0B      MOV  X0Bh, R4
0x0FF9 8D 0C      MOV  X0Ch, R5
0x0FFB E4         CLR A 
0x0FFC F5 0D      MOV  X0Dh, A
0x0FFE FF         MOV R7, A 
0x0FFF FE         MOV R6, A 
;
; Jump Target - Callers: 1025 		; read loop from dptr table at 0C15
0x1000 C3         CLR C 
0x1001 EF         MOV A, R7 
0x1002 95 0C      SUBB A,  X0Ch
0x1004 EE         MOV A, R6 
0x1005 95 0B      SUBB A,  X0Bh
0x1007 50 1E      JNC  0x1027		; branch if Carry not set
0x1009 AB 08      MOV R3,  X08h
0x100B AA 09      MOV R2,  X09h
0x100D A9 0A      MOV R1,  X0Ah
0x100F 8F 82      MOV  DPL, R7
0x1011 8E 83      MOV  DPH, R6
0x1013 12 0E 2C   LCALL  0x0E2C		; read register value based upon  R3, C, R1,R2,DPL,dph
0x1016 65 0D      XRL A,  X0Dh		; XOR RAM value with (0D)
0x1018 F5 0E      MOV  X0Eh, A		; store the XOR result in 0E
0x101A 90 0C 15   MOV DPTR,  #0x0C15	
0x101D 93         MOVC A, @A+DPTR 	; use it as offset to read data (again) from table 0C15
0x101E F5 0D      MOV  X0Dh, A		; store new register 0D
0x1020 0F         INC R7 
0x1021 BF 00 01   CJNE R7,  #0x00, 0x1025	; keep looping on R7 unless = 00
0x1024 0E         INC R6 			; then increment dph and keep looping, eg 0c to 0d
;
; Jump Target - Callers: 1021 
0x1025 80 D9      SJMP  0x1000		; loop
;
; branch Target - Callers: 1007 
0x1027 AF 0D      MOV R7,  X0Dh		; load R7 from register 0D if Carry not set
0x1029 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Data in FLASH Space			; need to manually decode this section, missed by dasm
0x102A            0x7F ()
0x102B            0x01
0x102C            0x12
0x102D            0x12
0x102E            0xB9
0x102F            0xC2
0x1030            0x93
0x1031            0xE4
0x1032            0xF5
0x1033            0x1F
0x1034            0xF5
0x1035            0x20 ( )
0x1036            0xF5
0x1037            0x21 (!)
0x1038            0xF5
0x1039            0x22 (")
0x103A            0x7F ()
0x103B            0x0A
0x103C            0x7E (~)
0x103D            0x00
0x103E            0x7D (})
0x103F            0x00
0x1040            0x7C (|)
0x1041            0x00
0x1042            0x12
0x1043            0x12
0x1044            0x30 (0)
0x1045            0xEF
0x1046            0x70 (p)
0x1047            0x05
0x1048            0x12
0x1049            0x12
0x104A            0xB5
0x104B            0x80
0x104C            0xED
0x104D            0xE5
0x104E            0x1E
0x104F            0x70 (p)
0x1050            0x05
0x1051            0x7F ()
0x1052            0x01
0x1053            0x12
0x1054            0x12
0x1055            0xBC
0x1056            0x75 (u)
0x1057            0x1D
0x1058            0x01
0x1059            0xE4
0x105A            0xFF
0x105B            0x02
0x105C            0x12
0x105D            0xB9
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;
;   insert manual decode starting at 102A
;
;					1ST JUMP TARGET OF SECONDARY LOOP
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0x102A 7F01  		MOV R7, #1h         
  102C 1212B9		LCALL 0x12B9        ; save R7 in RAM 27
  102F C293  		CLR P1.3
  1031 E4    		CLR A
  1032 F51F  		MOV 1Fh, A          ; turn off LED and clear some registers
  1034 F520  		MOV 20h, A
  1036 F521  		MOV 21h, A
  1038 F522  		MOV 22h, A
;
0x103A 7F0A  		MOV R7, #0Ah        ; loop
  103C 7E00  		MOV R6, #0h
  103E 7D00  		MOV R5, #0h
  1040 7C00  		MOV R4, #0h
0x1042 121230		LCALL 0x1230   ? ; ; Reg 23-26 differenced with R4-7 to set/clear Carry and load R7 0/1
  1045 EF    		MOV A, R7
  1046 7005  		JNZ 0x104D
0x1048 1212B5		LCALL 0x12B5	; clear Reg 29
  104B 80ED  		SJMP 0x103A           ; jump back up to loop
;
0x104D E51E  		MOV A, 1Eh                  ; branch on R7 not zero
  104F 7005  		JNZ L0280       ; is 1E =0 ?
  1051 7F01  		MOV R7, #1h
0x1053 1212BC		LCALL 0x12BC	; save R7=1 in RAM 2D
L0280:
  1056 751D01		MOV 1Dh, #1h
  1059 E4    		CLR A
  105A FF    		MOV R7, A
0x105B 0212B9		LJMP 0x12B9	;save R7=0 in RAM 27
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;					8th JUMP TARGET OF SECONDARY LOOP
;				grabs data from dptr table and sends it out the SPI
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers:                    
0x105E C2 93      CLR  P1.3
0x1060 E5 20      MOV A,  X20h
0x1062 B4 3C 0A   CJNE A,  #0x3C, 0x106F		; check if 20 = #3C
0x1065 E5 21      MOV A,  X21h
0x1067 B4 A5 05   CJNE A,  #0xA5, 0x106F		; check if 21 = #A5 , (key for flkey write?)
0x106A E4         CLR A 
0x106B F5 1E      MOV  X1Eh, A			; load 1E = 0 and skip over
0x106D 80 0F      SJMP  0x107E
;
; Jump Target - Callers: 1062 1067 
0x106F E5 20      MOV A,  X20h
0x1071 B4 3B 0A   CJNE A,  #0x3B, 0x107E		; check if 20 = #3B
0x1074 E5 21      MOV A,  X21h
0x1076 25 E0      ADD A,  ACC			; add 21 to itself plus carry
0x1078 54 7E      ANL A,  #0x7E			; mask lower 7 bits of result, and
0x107A F5 41      MOV  X41h, A		
0x107C F5 1E      MOV  X1Eh, A			; store result in 41 and 1E
;
; Jump Target - Callers: 1071 106D 
0x107E 7B 00      MOV R3,  #0x00			; preload memory location pointers
0x1080 7A 00      MOV R2,  #0x00
0x1082 79 1F      MOV R1,  #0x1F
0x1084 12 10 8B   LCALL  0x108B			; read data and send it out SPI
0x1087 E4         CLR A 
0x1088 F5 1D      MOV  X1Dh, A			; clear flag register 1D (data was sent?)
0x108A 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
; Jump Target - Callers: 1084 
0x108B 8B 39      MOV  X39h, R3			; push gp registers
0x108D 8A 3A      MOV  X3Ah, R2
0x108F 89 3B      MOV  X3Bh, R1
0x1091 E4         CLR A 
0x1092 F5 3C      MOV  X3Ch, A
0x1094 7F 01      MOV R7,  #0x01			; set R7 flag which
0x1096 12 12 9F   LCALL  0x129F		; sets the Chip Select Low
0x1099 AB 39      MOV R3,  X39h
0x109B AA 3A      MOV R2,  X3Ah			; pop gp registers
0x109D A9 3B      MOV R1,  X3Bh
0x109F 7D 04      MOV R5,  #0x04			; load counter or pointer
0x10A1 7C 00      MOV R4,  #0x00
0x10A3 12 0F B6   LCALL  0x0FB6		; [grab data at dptr and sends it out the SPI]
;
; loop Target - Callers: 10B0 
0x10A6 E5 3C      MOV A,  X3Ch		; loop
0x10A8 C3         CLR C 
0x10A9 94 00      SUBB A,  #0x00
0x10AB 50 05      JNC  0x10B2
0x10AD 00         NOP 
0x10AE 05 3C      INC  X3Ch
0x10B0 80 F4      SJMP  0x10A6		; back to loop
;
; Jump Target - Callers: 10AB 
0x10B2 E4         CLR A 
0x10B3 FF         MOV R7, A 
0x10B4 12 12 9F   LCALL  0x129F
0x10B7 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				4th Jump Table in [SEC]
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers:                
0x10B8 7B 00      MOV R3,  #0x00
0x10BA 7A 00      MOV R2,  #0x00
0x10BC 79 3F      MOV R1,  #0x3F
0x10BE 7F 0A      MOV R7,  #0x0A
0x10C0 7E 00      MOV R6,  #0x00
0x10C2 7D 00      MOV R5,  #0x00
0x10C4 7C 00      MOV R4,  #0x00
0x10C6 12 0E D7   LCALL  0x0ED7
0x10C9 EF         MOV A, R7 
0x10CA 64 01      XRL A,  #0x01
0x10CC 60 04      JZ  0x10D2
0x10CE E4         CLR A 
0x10CF F5 1D      MOV  X1Dh, A
0x10D1 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
; Jump Target - Callers: 10CC 
0x10D2 85 3F 21   MOV  X21h, X3Fh
0x10D5 E5 1F      MOV A,  X1Fh
0x10D7 30 E0 04   JNB  ACC.0, 0x10DE
0x10DA 7F 04      MOV R7,  #0x04
0x10DC 80 02      SJMP  0x10E0
;
; Jump Target - Callers: 10D7 
0x10DE 7F 06      MOV R7,  #0x06
;
; Jump Target - Callers: 10DC 
0x10E0 8F 1D      MOV  X1Dh, R7
0x10E2 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				[Secondary Loop]
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 11CE           - Pre-initializer for secondard jump table routine
0x10E3 E4         CLR A                 ; will result in first entry in jump table being taken.
0x10E4 F5 1F      MOV  X1Fh, A
0x10E6 F5 20      MOV  X20h, A
0x10E8 F5 21      MOV  X21h, A		; clear some RAM
0x10EA F5 22      MOV  X22h, A
0x10EC F5 1D      MOV  X1Dh, A
;
; Jump Target - Callers: 1108           	; loop
;					; reads 0D15 table secondary loop routine
0x10EE E5 1D      MOV A,  X1Dh
0x10F0 75 F0 03   MOV  B, #0x03
0x10F3 A4         MUL AB                ; Multiply RAM 0x1D by three
0x10F4 24 15      ADD A,  #0x15         ; Add 0x15
0x10F6 F5 82      MOV  DPL, A           ; Use that value for DPL
0x10F8 E4         CLR A 
0x10F9 34 0D      ADDC A,  #0x0D
0x10FB F5 83      MOV  DPH, A           ; set DPH to 0x0D
0x10FD 74 01      MOV A,  #0x01		; skip over the xFF separator byte
0x10FF 93         MOVC A, @A+DPTR 	; get first address byte DPTR = 0D15 + offset from X1D
0x1100 FA         MOV R2, A 		; put into R2 = dph
0x1101 74 02      MOV A,  #0x02
0x1103 93         MOVC A, @A+DPTR 	; second byte
0x1104 F9         MOV R1, A 		; goes into R1 = dpl
0x1105 12 0E 7C   LCALL  0x0E7C         ; jumps program to setting of R2,R1 from dptr read
;					; Do the actual jump to the jump table entry.
0x1108 80 E4      SJMP  0x10EE          ; Infinite (ish) loop
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				Timer2 O/F Service Routine
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 0C12           - Timer2 Overflow interrupt actual implementation
0x110A C0 E0      PUSH  ACC             ; save existing value of accum and processor status
0x110C C0 D0      PUSH  PSW
0x110E E5 27      MOV A,  X27h          ; Grab value of RAM 0x27
0x1110 60 03      JZ  0x1115            ; Skip the below move if 0x27 was 0.
0x1112 75 EC FF   MOV  PCACPH2, #0xFF   ; set PCA capture module high byte 2 to 0xFF (Reset watchdog timer)
;
; Jump Target - Callers: 1110 
0x1115 E5 26      MOV A,  X26h          ; Grab value from RAM 0x26 - Start a cascading 32 bit increment. 
;					; 0x23 - 0x26 form a 32 bit counter
0x1117 24 01      ADD A,  #0x01         ; Add one
0x1119 F5 26      MOV  X26h, A          ; Store it back to RAM 0x26
0x111B E4         CLR A                 
0x111C 35 25      ADDC A,  X25h         ; Add Carry Flag + RAM 0x25
0x111E F5 25      MOV  X25h, A          ; Store result back to RAM 0x25
0x1120 E4         CLR A 
0x1121 35 24      ADDC A,  X24h         ; Add carry flag + RAM 0x24
0x1123 F5 24      MOV  X24h, A          ; Store result back to RAM 0x24
0x1125 E4         CLR A 
0x1126 35 23      ADDC A,  X23h         ; Add carry flag + RAM 0x23
0x1128 F5 23      MOV  X23h, A          ; Store result back to RAM 0x23
0x112A C2 CF      CLR  TMP2CN.7         ; clear timer 2 high byte overflow flag
0x112C D0 D0      POP  PSW              ; Restore registers we saved at the beginning
0x112E D0 E0      POP  ACC
0x1130 32         RETI
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				Setup Timers
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 11BA 1207      - Set up timer1 and timer2 (Timer1 is for UART)
0x1131 E5 28      MOV A,  X28h          ; copy value from RAM 0x28 to accum
0x1133 70 1E      JNZ  0x1153           ; If it wasn't zero then just return
0x1135 D2 8E      SETB  TCON.6          ; Enable timer 1
0x1137 75 89 20   MOV  TMOD, #0x20      ; Timer Mode 0010 0000 = Mode 2 - 8 Bit auto reload
0x113A 75 8D EC   MOV  TH1, #0xEC       ; Timer 1 high byte = 0xEC
0x113D 75 8E 18   MOV  CKCON, #0x18     ; CKCON = 0001 1000 = Timer 2 low byte uses system clock, timer 1 uses system clock
0x1140 D2 CA      SETB  TMP2CN.2        ; Set TMR2CN bit 2 = Timer 2 is enabled
0x1142 C2 CB      CLR  TMP2CN.3         ; Clear timer 2 CN bit 3 = operate in 16 bit mode
0x1144 75 CA 6F   MOV  TMR2RLL, #0x6F   ; Set up timer count registers
0x1147 75 CB FE   MOV  TMR2RLH, #0xFE
0x114A 75 CC 6F   MOV  TMP2L, #0x6F
0x114D 75 CD FE   MOV  TMR2H, #0xFE
0x1150 75 28 01   MOV  X28h, #0x01
;
; Jump Target - Callers: 1133 
0x1153 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				3rd Jump Target [SEC]
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers:                  ;
0x1154 7B 00      MOV R3,  #0x00
0x1156 7A 00      MOV R2,  #0x00
0x1158 79 3E      MOV R1,  #0x3E
0x115A 7F 0A      MOV R7,  #0x0A
0x115C 7E 00      MOV R6,  #0x00
0x115E 7D 00      MOV R5,  #0x00
0x1160 7C 00      MOV R4,  #0x00
0x1162 12 0E D7   LCALL  0x0ED7		; 
0x1165 EF         MOV A, R7 
0x1166 64 01      XRL A,  #0x01
0x1168 60 04      JZ  0x116E
0x116A E4         CLR A 
0x116B F5 1D      MOV  X1Dh, A
0x116D 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
; Jump Target - Callers: 1168 
0x116E 85 3E 20   MOV  X20h, X3Eh
0x1171 75 1D 03   MOV  X1Dh, #0x03
0x1174 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;				5th Jump Target [SEC]
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers:			; 
0x1175 7B 00      MOV R3,  #0x00
0x1177 7A 00      MOV R2,  #0x00
0x1179 79 40      MOV R1,  #0x40
0x117B 7F 0A      MOV R7,  #0x0A
0x117D 7E 00      MOV R6,  #0x00
0x117F 7D 00      MOV R5,  #0x00
0x1181 7C 00      MOV R4,  #0x00
0x1183 12 0E D7   LCALL  0x0ED7		; 
0x1186 EF         MOV A, R7 
0x1187 64 01      XRL A,  #0x01
0x1189 60 04      JZ  0x118F
0x118B E4         CLR A 
0x118C F5 1D      MOV  X1Dh, A
0x118E 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
; Jump Target - Callers: 1189 
0x118F 85 40 22   MOV  X22h, X40h
0x1192 75 1D 05   MOV  X1Dh, #0x05
0x1195 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				SPI zero byte send and read reply
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 0F92 0F97 0EC0     - Routine clocks out a zero byte on SPI so it can read back a reply byte
0x1196 C2 AF      CLR  IE.7                 ; Disable global interrupts
0x1198 C2 AF      CLR  IE.7
;
; Jump Target - Callers: 119C 
0x119A E5 A1      MOV A,  SPICFG            ; get SPI config
0x119C 20 E7 FB   JB  ACC.7, 0x119A         ; Wait unti SPI not busy
0x119F D2 AF      SETB  IE.7                ; Re enable interrupts
;
; Jump Target - Callers: 11A1 
0x11A1 30 F9 FD   JNB  SPICN.1, 0x11A1      ; Wait until TX buff empty flag says we can send a byte
0x11A4 E4         CLR A 
0x11A5 F5 A3      MOV  SPIDAT, A            ; Send a zero byte
0x11A7 C2 AF      CLR  IE.7                 ; Turn off interrupts
0x11A9 C2 AF      CLR  IE.7
;
; Jump Target - Callers: 11AD 
0x11AB E5 A1      MOV A,  SPICFG            ; Get SPI config
0x11AD 20 E7 FB   JB  ACC.7, 0x11AB         ; Wait until SPI not busy
0x11B0 D2 AF      SETB  IE.7                ; Re enable interrupts
0x11B2 AF A3      MOV R7,  SPIDAT           ; Get byte from SPI and store it in R7
0x11B4 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				Secondary Start InitHware
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 0D39               - Start events that ends with a secondary infinite loop being entered.
;
0x11B5 12 12 59   LCALL  0x1259             ; do early hardware setup stuff (again?! With duplicate of the routines)
0x11B8 D2 93      SETB  P1.3                ; Turn on LED
0x11BA 12 11 31   LCALL  0x1131             ; Set up timer1 and timer2
0x11BD 12 12 03   LCALL  0x1203             ; Set up UART
0x11C0 12 12 1A   LCALL  0x121A             ; Set up SPI
0x11C3 E4         CLR A 
0x11C4 F5 1E      MOV  X1Eh, A              ; Clear RAM 0x1E
0x11C6 12 0F 72   LCALL  0x0F72             ; [ SPI, WRITE AND READ READ ]
;
0x11C9 12 12 A9   LCALL  0x12A9		; IE = #B0, 
;
0x11CC C2 93      CLR  P1.3                 ; turn off LED
0x11CE 12 10 E3   LCALL  0x10E3             ; Enters secondardy infinite loop with jump table
0x11D1 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				SETUP PORTS AND CROSSBAR
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 1263               ; Set up pin configurations (duplicates routine at 0xA95)
0x11D2 75 A5 FF   MOV  P1MDOUT, #0xFF       ; Set P1 MDOUT to be all push/pull
0x11D5 75 A4 9D   MOV  P0MDOUT, #0x9D       ; Set P0 MDOUT to 1001 1101 (1 = Push/Pull, 0 = open drain)
0x11D8 75 80 6A   MOV  P0, #0x6A            ; Set P0 pins to 0110 1010 (0 = low, 1 = high)
0x11DB 75 D5 FF   MOV  P1SKIP, #0xFF        ; Set Skip to all 1's (skip all with crossbar)
0x11DE E4         CLR A 
0x11DF F5 90      MOV  P1, A                ; Set all P1 low
0x11E1 75 D4 F8   MOV  P0SKIP, #0xF8        ; Set P0 Skip to 1111 1000 (skip top 5 with crossbar)
0x11E4 75 E1 03   MOV  XBR0, #0x03          ; Set crossbar 0 to 0000 0011 (enable SPI and UART on pins)
0x11E7 75 E2 C0   MOV  XBR1, #0xC0          ; Set crossbar 1 to 1100 0000 (Disable weak pullups, enable crossbar)
0x11EA 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				6TH JUMP TARGET [SEC]
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers:                   
0x11EB 7B 00      MOV R3,  #0x00
0x11ED 7A 00      MOV R2,  #0x00
0x11EF 79 1F      MOV R1,  #0x1F
0x11F1 7D 04      MOV R5,  #0x04
0x11F3 7C 00      MOV R4,  #0x00
0x11F5 12 0F F1   LCALL  0x0FF1		; read data from 0C15 table to load registers 0D, 0E, R7
0x11F8 EF         MOV A, R7 
0x11F9 60 04      JZ  0x11FF		; examine result
0x11FB E4         CLR A 
0x11FC F5 1D      MOV  X1Dh, A		; clear register 1D = #0
0x11FE 22         RET 
;
; Jump Target - Callers: 11F9 		; or
0x11FF 75 1D 07   MOV  X1Dh, #0x07	; set register 1D = #07
0x1202 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				SETUP UART
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 11BD 121E          ; set up UART params
0x1203 E5 2E      MOV A,  X2Eh              ; Grab value from RAM 0x2E
0x1205 70 12      JNZ  0x1219               ; if it isn't zero then just return
0x1207 12 11 31   LCALL  0x1131             ; see if we need to set up timers and do it if we need to.
0x120A C2 9F      CLR  SCON.7               ; 8 bit uart mode
0x120C D2 9D      SETB  SCON.5              ; only activate if stop bit is 1
0x120E C2 9C      CLR  SCON.4               ; UART reception is disabled
0x1210 C2 98      CLR  SCON.0               ; clear receive interrupt flag
0x1212 C2 99      CLR  SCON.1               ; clear transmit interrupt flag
0x1214 D2 9C      SETB  SCON.4              ; UART reception is now enabled.
0x1216 75 2E 01   MOV  X2Eh, #0x01          ; Set flag saying we configured UART.
;
; Jump Target - Callers: 1205 
0x1219 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				SETUP SPI
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 11C0               
0x121A E5 42      MOV A,  X42h              ; get value from 0x42
0x121C 70 11      JNZ  0x122F               ; If it wasn't zero then just return
0x121E 12 12 03   LCALL  0x1203             ; Make sure UART is configured.
0x1221 75 A2 0C   MOV  SPICKR, #0x0C        ; 1100 0000 = 24.5mhz / ((2 * (192 + 1)) = 634,715
0x1224 75 A1 60   MOV  SPICFG, #0x60        ; 0110 0000 = Operate as master mode, PHA = 1, POL = 0
0x1227 E4         CLR A 
0x1228 F5 F8      MOV  SPICN, A             ; CN = 0 Clear all flags, 3 wire master mode, SPI not enabled
0x122A D2 F8      SETB  SPICN.0             ; Now enable SPI
0x122C 75 42 01   MOV  X42h, #0x01          ; Say that we've got SPI set up now
;
; Jump Target - Callers: 121C 
0x122F 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				?
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 0EF4 
0x1230 AB 26      MOV R3,  X26h
0x1232 AA 25      MOV R2,  X25h
0x1234 A9 24      MOV R1,  X24h
0x1236 A8 23      MOV R0,  X23h
0x1238 D3         SETB C 
0x1239 12 0E 6B   LCALL  0x0E6B		; ZZZ
0x123C 40 04      JC  0x1242
0x123E 7F 01      MOV R7,  #0x01
0x1240 80 02      SJMP  0x1244
;
; Jump Target - Callers: 123C 
0x1242 7F 00      MOV R7,  #0x00
;
; Jump Target - Callers: 1240 
0x1244 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;			[SEC] InitMem data table
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; InitMem Data Table		      ; from 0D74
0x1245            0x06	; # of bytes
0x1246            0x23 	; starting RAM register location
0x1247            0x00	23
0x1248            0x00	24
0x1249            0x00	25
0x124A            0x00	26
0x124B            0x00	27
0x124C            0x00	28
0x124D            0x01	; # of bytes
0x124E            0x42 
0x124F            0x00	42
0x1250            0x06	; # bytes
0x1251            0x29 
0x1252            0x00	29
0x1253            0x00	2A
0x1254            0x00	2B
0x1255            0x01	2C
0x1256            0x00	2D
0x1257            0x00	2E
0x1258            0x00	; EOD END OF DATA
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				[SEC] InitHware
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 11B5 
0x1259 C2 AF      CLR  IE.7             ; disable interrupts
0x125B C2 AF      CLR  IE.7
0x125D 12 12 88   LCALL  0x1288         ; Enable VDDMON, set it as reset source
0x1260 12 0C 03   LCALL  0x0C03         ; Set up PCA
0x1263 12 11 D2   LCALL  0x11D2         ; Set up physical pins of Ports
0x1266 02 12 AD   LJMP  0x12AD          ; Set up oscillator and return from top call
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				UART transmit R7
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 0EC5 
0x1269 E5 2B      MOV A,  X2Bh          ; Check UART handler's transmitting flag and loop
0x126B 70 FC      JNZ  0x1269           ; If it isn't zero then keep checking until it is.
0x126D C2 AF      CLR  IE.7             ; Then globally block interrupts
0x126F C2 AF      CLR  IE.7
0x1271 8F 99      MOV  SBUF, R7         ; And transmit R7 into UART
0x1273 75 2B 01   MOV  X2Bh, #0x01      ; Then set UART handler transmitting flag
0x1276 D2 AF      SETB  IE.7            ; And re-enable interrupts
0x1278 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				7TH JUMP TABLE IN SECONDARY LOOP
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers:                
0x1279 C2 93      CLR  P1.3             ; Bring LED pin low
0x127B 7B 00      MOV R3,  #0x00
0x127D 7A 00      MOV R2,  #0x00        ; Set three registers (R1=1F, R2=R3=0)
0x127F 79 1F      MOV R1,  #0x1F
0x1281 12 0E 82   LCALL  0x0E82         ; Looks up bytes in flash and sends them out SPI then sends out UART
0x1284 E4         CLR A 
0x1285 F5 1D      MOV  X1Dh, A          ; Clear out RAM 0x1D
0x1287 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;				Setup VddMon [SEC]
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 125D           - Turn on VDDMON and set it as reset source.
0x1288 E4         CLR A                 
0x1289 FF         MOV R7, A             ;Set R7 = 0
0x128A 75 FF 80   MOV  VDDMON, #0x80    ;Turn VDDMON on

; Jump Target - Callers: 128E 
0x128D 0F         INC R7 
0x128E BF 14 FC   CJNE R7,  #0x14, 0x128D   ;Do 14 loops
0x1291 75 EF 02   MOV  RSTSRC, #0x02        ;enable VDDMON as reset source
0x1294 22         RET
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				Clear 32-bits RAM 23-26
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Jump Target - Callers: 0E0E 0EE5 
0x1295 E4         CLR A 
0x1296 F5 26      MOV  X26h, A
0x1298 F5 25      MOV  X25h, A
0x129A F5 24      MOV  X24h, A
0x129C F5 23      MOV  X23h, A
0x129E 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;				State of Chip Select
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 0F82 0F9E 0E91 0ECE 10B4 1096   R7=0 means set Chip Sel high, otherwise set CS Low
0x129F EF         MOV A, R7 
0x12A0 60 03      JZ  0x12A5            ; Was R7 0? Jump to 12A5 (set carry flag)
0x12A2 C3         CLR C                 ; If R7 wasn't zero then clear carry flag
0x12A3 80 01      SJMP  0x12A6          ; and continue on skipping  the next line that would have set it
;
; Jump Target - Callers: 12A0 
0x12A5 D3         SETB C                ; If R7 was zero then set the carry flag
;
; Jump Target - Callers: 12A3 
0x12A6 92 83      MOV  P0.3, C          ; Set state of chip select to value of carry flag 
;					; (So, if R7 was 0 then set CS High, otherwise CS is Low)
0x12A8 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;				Setup Global Interrupt Enable [SEC]
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 11C9 
0x12A9 75 A8 B0   MOV  IE, #0xB0
0x12AC 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				Setup Oscillator [SEC]
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 1266           Duplicate of early start up routine that sets oscillator with same settings
0x12AD 75 B2 C7   MOV  OSCICN, #0xC7    ; set OSC ICN to 1100 0111 = Enabled in normal mode, Sysclock is oscillator / 1
0x12B0 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				Setup Timer2 Mode [SEC]
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Called from:     none found		; * kenny notes
; Data in FLASH Space                   *Manually decode, they are called from code at 102A, which is also tagged data
0x12B1 75 C9 40   MOV  sfrC9, #40         ;*
0x12B2            0xC9
0x12B3            0x40
0x12B4 22         RET                   ;*
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				Clear Ram 29
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Called from:	1048			; 
0x12B5 E4         CLR A                 ; *
0x12B6 F5 29      MOV X29, A            ; *
0x12B7            0x29
0x12B8 22         RET                   ; *
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				R7 -> RAM 27
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 0F29 0F6E 
0x12B9 8F 27      MOV  X27h, R7
0x12BB 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				R7 -> RAM 2D
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 0F4D 0F46 
0x12BC 8F 2D      MOV  X2Dh, R7
0x12BE 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
;				R7 -> RAM 2C
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Jump Target - Callers: 0E8C 0ED3 
0x12BF 8F 2C      MOV  X2Ch, R7
0x12C1 22         RET 
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; end of code space
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
; Data in FLASH Space
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0x12C2            0xFF
0x12C3            0xFF
0x12C4            0xFF
;...				; removed duplicates
0x19FE            0xFF
0x19FF            0xFF
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
;				; start of 14th page
0x1A00            0x03          ; buried data byte for read call from 072A, 
0x1A01            0xFF
0x1A02            0xFF
0x1A03            0xFF
;...
0x1BFC            0xFF
0x1BFD            0xFF
0x1BFE            0x92		; bytes at top of 14th page of 512 Bytes of memory called from xxxx
0x1BFF            0x18
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0x1C00            0xFF		; start of 15th page
0x1C01            0xFF
0x1C02            0xFF
;...
0x1CFD            0xFF
0x1CFE            0xFF
0x1CFF            0xFF
0x1D00            0x32 (2)	; start of memory with QR label, serial number from board
0x1D01            0x00
0x1D02            0x31 (1)		; board number ?
0x1D03            0x30 (0)
0x1D04            0x32 (2)
0x1D05            0x31 (1)
0x1D06            0x37 (7)
0x1D07            0x34 (4)
0x1D08            0x39 (9)
0x1D09            0x2D (-)
0x1D0A            0x30 (0)
0x1D0B            0x30 (0)
0x1D0C            0x2D (-)
0x1D0D            0x42 (B)
0x1D0E            0x00
0x1D0F            0x00
0x1D10            0x00
0x1D11            0x00
0x1D12            0x00
0x1D13            0x00
0x1D14            0x00
0x1D15            0x00
0x1D16            0x30 (0)		; serial number
0x1D17            0x33 (3)
0x1D18            0x31 (1)
0x1D19            0x34 (4)
0x1D1A            0x43 (C)
0x1D1B            0x31 (1)
0x1D1C            0x30 (0)
0x1D1D            0x30 (0)
0x1D1E            0x30 (0)
0x1D1F            0x30 (0)
0x1D20            0x38 (8)
0x1D21            0x30 (0)
0x1D22            0x38 (8)
0x1D23            0x00
0x1D24            0x31 (1)		; board number
0x1D25            0x30 (0)
0x1D26            0x30 (0)
0x1D27            0x39 (9)
0x1D28            0x33 (3)
0x1D29            0x31 (1)
0x1D2A            0x32 (2)
0x1D2B            0x2D (-)
0x1D2C            0x30 (0)
0x1D2D            0x30 (0)
0x1D2E            0x2D (-)
0x1D2F            0x45 (E)
0x1D30            0x00
0x1D31            0x00
0x1D32            0x00
0x1D33            0x00
0x1D34            0x00
0x1D35            0x00
0x1D36            0x00
0x1D37            0x00
0x1D38            0x54 (T)		; tesla part number
0x1D39            0x31 (1)
0x1D3A            0x34 (4)
0x1D3B            0x43 (C)
0x1D3C            0x30 (0)
0x1D3D            0x36 (6)
0x1D3E            0x31 (1)
0x1D3F            0x38 (8)
0x1D40            0x33 (3)
0x1D41            0x39 (9)
0x1D42            0x33 (3)
0x1D43            0x00
0x1D44            0x00
0x1D45            0x00		
0x1D46            0x90		; hidden data bytes or security bytes ?
0x1D47            0xB5		
0x1D48            0xCD		; 90 B5 CD 84 E8
0x1D49            0x84
0x1D4A            0xE8
0x1D4B            0xFF		; back to blanks xFF, and not erased empties x00
0x1D4C            0xFF
0x1D4D            0xFF		
0x1D4E            0xFF
0x1D4F            0xFF
;...
0x1DFD            0xFF
0x1DFE            0xFF
0x1DFF            0xFF
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0x1E00            0x00		; start of reserved section ? the top page(ref. 8051 manual)
0x1E01            0x00		; appears to be erased empty memory page, x00
0x1E02            0x00
0x1E03            0x00
0x1E04            0x00
;...
0x1FFB            0x00
0x1FFC            0x00
0x1FFD            0x00
0x1FFE            0x00
0x1FFF            0x00		; end of Flash memory
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
